<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>元件製作器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', '微軟正黑體', sans-serif;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        canvas {
            background-color: #1a202c; /* Dark Blue */
            cursor: default;
        }
        .tool-item.active {
            @apply bg-blue-600 ring-2 ring-blue-300;
        }
        #code-area {
            font-family: 'Courier New', Courier, monospace;
            white-space: pre;
            background-color: #2d3748;
            color: #a0aec0;
            border-radius: 8px;
            padding: 1rem;
            font-size: 14px;
            line-height: 1.5;
            overflow-x: auto;
            border: 1px solid #4a5568;
        }
        #text-editor {
            position: absolute;
            display: none;
            background-color: #4a5568;
            color: white;
            border: 1px solid #a0aec0;
            padding: 2px;
            font-family: 'Inter', '微軟正黑體', sans-serif;
            z-index: 100;
        }
        button:disabled {
            @apply opacity-50 cursor-not-allowed;
        }
    </style>
</head>
<body class="bg-gray-800 text-white h-screen flex flex-col md:flex-row overflow-hidden">

    <!-- Main Content -->
    <div class="flex-1 flex flex-col p-4 gap-4">
        <h1 class="text-2xl font-bold text-center">元件製作器</h1>
        <div id="canvas-wrapper" class="flex-1 bg-gray-700 rounded-lg overflow-hidden shadow-lg relative">
            <canvas id="canvas"></canvas>
            <input type="text" id="text-editor" />
        </div>
    </div>

    <!-- Toolbar & Output -->
    <div class="w-full md:w-96 bg-gray-900 p-4 flex flex-col gap-4 overflow-y-auto">
        <div>
            <h2 class="text-xl font-bold mb-2">工具列</h2>
            <div class="grid grid-cols-3 gap-2">
                <button class="tool-item bg-gray-700 hover:bg-gray-600 p-2 rounded active" data-type="select">移動/選取</button>
                <button class="tool-item bg-gray-700 hover:bg-gray-600 p-2 rounded" data-type="line">畫線</button>
                <button class="tool-item bg-gray-700 hover:bg-gray-600 p-2 rounded" data-type="rect">畫矩形</button>
                <button class="tool-item bg-gray-700 hover:bg-gray-600 p-2 rounded" data-type="circle">畫圓形</button>
                <button class="tool-item bg-gray-700 hover:bg-gray-600 p-2 rounded" data-type="knob">調整紐</button>
                <button class="tool-item bg-gray-700 hover:bg-gray-600 p-2 rounded" data-type="text">文字</button>
                <button class="tool-item bg-green-700 hover:bg-green-600 p-2 rounded" data-type="connector">接點</button>
                <button class="tool-item bg-red-700 hover:bg-red-600 p-2 rounded col-span-2" data-type="delete">刪除</button>
            </div>
        </div>

        <div class="flex flex-col gap-2">
            <button id="add-function-btn" class="w-full bg-purple-600 hover:bg-purple-500 p-3 rounded-lg font-bold text-lg shadow-md">新增功能</button>
            <button id="rotate-btn" class="w-full bg-yellow-600 hover:bg-yellow-500 p-3 rounded-lg font-bold text-lg shadow-md">旋轉 90°</button>
            <div class="grid grid-cols-2 gap-2 mt-2">
                 <button id="export-btn" class="w-full bg-blue-600 hover:bg-blue-500 p-3 rounded-lg font-bold shadow-md">🚀 產生</button>
                 <button id="load-btn" class="w-full bg-teal-600 hover:bg-teal-500 p-3 rounded-lg font-bold shadow-md">📥 讀取</button>
            </div>
        </div>
        
        <div class="flex-1 flex flex-col min-h-0">
             <h2 class="text-xl font-bold mb-2">程式碼</h2>
             <div id="code-output-container" class="flex-1 min-h-0">
                <textarea id="code-area" class="w-full h-full" spellcheck="false">點擊「產生」以產生程式碼...</textarea>
             </div>
        </div>
    </div>
    
    <!-- Function Modal -->
    <div id="function-modal" class="hidden absolute z-50 bg-gray-700 rounded-lg shadow-xl p-4 w-64 border border-gray-500">
        <h3 class="text-lg font-bold mb-4 text-white">選擇功能</h3>
        <div class="flex flex-col gap-2">
            <button id="func-conductive-btn" class="w-full text-left bg-gray-600 hover:bg-gray-500 p-2 rounded text-white">相通</button>
            <button id="func-coil-btn" class="w-full text-left bg-blue-600 hover:bg-blue-500 p-2 rounded text-white">線圈</button>
            <button id="func-a-contact-btn" class="w-full text-left bg-green-600 hover:bg-green-500 p-2 rounded text-white">瞬時A接點 (NO)</button>
            <button id="func-b-contact-btn" class="w-full text-left bg-red-600 hover:bg-red-500 p-2 rounded text-white">瞬時B接點 (NC)</button>
            <button id="func-timed-a-contact-btn" class="w-full text-left bg-green-800 hover:bg-green-700 p-2 rounded text-white">限時A接點 (NO-T)</button>
            <button id="func-timed-b-contact-btn" class="w-full text-left bg-red-800 hover:bg-red-700 p-2 rounded text-white">限時B接點 (NC-T)</button>
        </div>
    </div>


<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const canvasWrapper = document.getElementById('canvas-wrapper');
    const textEditor = document.getElementById('text-editor');
    const exportBtn = document.getElementById('export-btn');
    const loadBtn = document.getElementById('load-btn');
    const addFunctionBtn = document.getElementById('add-function-btn');
    const rotateBtn = document.getElementById('rotate-btn');
    const codeArea = document.getElementById('code-area');
    const functionModal = document.getElementById('function-modal');
    const funcConductiveBtn = document.getElementById('func-conductive-btn');
    const funcCoilBtn = document.getElementById('func-coil-btn');
    const funcAContactBtn = document.getElementById('func-a-contact-btn');
    const funcBContactBtn = document.getElementById('func-b-contact-btn');
    const funcTimedAContactBtn = document.getElementById('func-timed-a-contact-btn');
    const funcTimedBContactBtn = document.getElementById('func-timed-b-contact-btn');


    const GRID_SIZE = 20;
    const HANDLE_SIZE = 8;
    let drawingElements = [];
    let componentFunctions = [];
    let elementIdCounter = 0;
    let activeTool = 'select';
    let selectedElements = [];
    let editingTextElement = null;
    let connectorPreviewPos = null;
    
    let isDrawing = false;
    let isDragging = false;
    let isMarqueeSelecting = false;
    let isResizing = false;
    let isPanning = false;
    let isAdjustingKnob = false;
    let adjustingKnob = null;
    let resizingElement = null;
    let resizeHandle = null;
    let startPos = {x:0, y:0};
    let currentPos = {x:0, y:0};
    let dragOffset = {x:0, y:0};
    let dragStartPositions = new Map();
    let panStart = {x: 0, y: 0};

    let scale = 1;
    let viewOffsetX = 0;
    let viewOffsetY = 0;

    // --- Coordinate Transformation ---
    function screenToWorld(x, y) {
        return { x: (x - viewOffsetX) / scale, y: (y - viewOffsetY) / scale };
    }
    function worldToScreen(x, y) {
        return { x: x * scale + viewOffsetX, y: y * scale + viewOffsetY };
    }

    function resizeCanvas() {
        const container = canvas.parentElement;
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        draw();
    }

    function drawGrid() {
        ctx.strokeStyle = `rgba(255, 255, 255, ${Math.max(0.1, 0.2 / scale)})`;
        ctx.lineWidth = 0.5 / scale;
        const viewLeft = -viewOffsetX / scale;
        const viewTop = -viewOffsetY / scale;
        const viewRight = (canvas.width - viewOffsetX) / scale;
        const viewBottom = (canvas.height - viewOffsetY) / scale;
        const startX = Math.floor(viewLeft / GRID_SIZE) * GRID_SIZE;
        const startY = Math.floor(viewTop / GRID_SIZE) * GRID_SIZE;

        for (let x = startX; x < viewRight; x += GRID_SIZE) {
            ctx.beginPath(); ctx.moveTo(x, viewTop); ctx.lineTo(x, viewBottom); ctx.stroke();
        }
        for (let y = startY; y < viewBottom; y += GRID_SIZE) {
            ctx.beginPath(); ctx.moveTo(viewLeft, y); ctx.lineTo(viewRight, y); ctx.stroke();
        }
    }

    function getResizeHandles(el) {
        if (!el || el.type !== 'rect') return {};
        const { x, y, width: w, height: h } = el;
        const hs = (HANDLE_SIZE / 2) / scale;
        return {
            'top-left':     { x: x - hs, y: y - hs, width: HANDLE_SIZE / scale, height: HANDLE_SIZE / scale }, 'top': { x: x + w/2 - hs, y: y - hs, width: HANDLE_SIZE / scale, height: HANDLE_SIZE / scale }, 'top-right': { x: x + w - hs, y: y - hs, width: HANDLE_SIZE / scale, height: HANDLE_SIZE / scale },
            'left':         { x: x - hs, y: y + h/2 - hs, width: HANDLE_SIZE / scale, height: HANDLE_SIZE / scale }, 'right': { x: x + w - hs, y: y + h/2 - hs, width: HANDLE_SIZE / scale, height: HANDLE_SIZE / scale },
            'bottom-left':  { x: x - hs, y: y + h - hs, width: HANDLE_SIZE / scale, height: HANDLE_SIZE / scale }, 'bottom': { x: x + w/2 - hs, y: y + h - hs, width: HANDLE_SIZE / scale, height: HANDLE_SIZE / scale }, 'bottom-right': { x: x + w - hs, y: y + h - hs, width: HANDLE_SIZE / scale, height: HANDLE_SIZE / scale },
        };
    }

    function getHandleAtPos(posX, posY, el) {
        const handles = getResizeHandles(el);
        for (const name in handles) {
            const h = handles[name];
            if (posX >= h.x && posX <= h.x + h.width && posY >= h.y && posY <= h.y + h.height) return name;
        }
        return null;
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(viewOffsetX, viewOffsetY);
        ctx.scale(scale, scale);

        drawGrid();
        const defaultColor = '#f6e05e';

        componentFunctions.forEach(func => {
            let color = null;
            let dash = [3, 3];
            switch(func.type) {
                case '相通': color = '#f472b6'; break;
                case 'coil': color = '#60a5fa'; dash = [4,4]; break;
                case 'a-contact': color = '#4ade80'; dash = [4,4]; break;
                case 'b-contact': color = '#f87171'; dash = [4,4]; break;
                case 'timed-a-contact': {
                    color = '#a855f7'; // Purple
                    dash = [4, 4];
                    const knob = drawingElements.find(e => e.id === func.knobId);
                    const connectors = func.connectors.map(id => drawingElements.find(el => el.id === id)).filter(Boolean);
                    if (knob && connectors.length === 2) {
                        ctx.save();
                        ctx.strokeStyle = '#f59e0b'; // amber-500
                        ctx.setLineDash([2 / scale, 2 / scale]);
                        ctx.lineWidth = 1 / scale;
                        ctx.beginPath();
                        ctx.moveTo(knob.x, knob.y);
                        const midX = (connectors[0].x + connectors[1].x) / 2;
                        const midY = (connectors[0].y + connectors[1].y) / 2;
                        ctx.lineTo(midX, midY);
                        ctx.stroke();
                        ctx.restore();
                    }
                    break;
                }
                case 'timed-b-contact': {
                    color = '#3b82f6'; // Blue
                    dash = [4, 4];
                    const knob = drawingElements.find(e => e.id === func.knobId);
                    const connectors = func.connectors.map(id => drawingElements.find(el => el.id === id)).filter(Boolean);
                    if (knob && connectors.length === 2) {
                        ctx.save();
                        ctx.strokeStyle = '#f59e0b'; // amber-500
                        ctx.setLineDash([2 / scale, 2 / scale]);
                        ctx.lineWidth = 1 / scale;
                        ctx.beginPath();
                        ctx.moveTo(knob.x, knob.y);
                        const midX = (connectors[0].x + connectors[1].x) / 2;
                        const midY = (connectors[0].y + connectors[1].y) / 2;
                        ctx.lineTo(midX, midY);
                        ctx.stroke();
                        ctx.restore();
                    }
                    break;
                }
            }

            if (color) {
                const connectorsInGroup = func.connectors.map(id => drawingElements.find(el => el.id === id)).filter(Boolean);
                if (connectorsInGroup.length > 1) {
                    ctx.save(); ctx.strokeStyle = color; ctx.setLineDash(dash.map(d => d / scale)); ctx.lineWidth = 1.5 / scale;
                     for (let i = 0; i < connectorsInGroup.length; i++) {
                        for (let j = i + 1; j < connectorsInGroup.length; j++) {
                           ctx.beginPath();
                           ctx.moveTo(connectorsInGroup[i].x, connectorsInGroup[i].y);
                           ctx.lineTo(connectorsInGroup[j].x, connectorsInGroup[j].y);
                           ctx.stroke();
                        }
                     }
                    ctx.restore();
                }
            }
        });

        drawingElements.forEach(el => {
            if (el === editingTextElement) return;
            ctx.save(); ctx.strokeStyle = defaultColor; ctx.lineWidth = 2 / scale; ctx.fillStyle = defaultColor;
            drawElement(ctx, el);
            ctx.restore();
        });
        
        if (selectedElements.length > 0) {
            ctx.save(); ctx.strokeStyle = '#38bdf8'; ctx.lineWidth = 2 / scale; ctx.shadowColor = '#38bdf8'; ctx.shadowBlur = 8 / scale;
            selectedElements.forEach(el => drawElement(ctx, el, true));
            ctx.restore();
        }

        if (resizingElement) {
            ctx.save(); ctx.fillStyle = '#38bdf8';
            const handles = getResizeHandles(resizingElement);
            for (const handle in handles) ctx.fillRect(handles[handle].x, handles[handle].y, handles[handle].width, handles[handle].height);
            ctx.restore();
        }

        if (isDrawing) {
             ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 2 / scale; ctx.setLineDash([5 / scale, 5 / scale]);
             if (activeTool === 'line') {
                 ctx.beginPath(); ctx.moveTo(startPos.x, startPos.y); ctx.lineTo(currentPos.x, currentPos.y); ctx.stroke();
             } else if (activeTool === 'rect') {
                 const rect = getMarqueeRect();
                 ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
                 if (rect.width > 0 && rect.height > 0) {
                    const gridWidth = Math.round(rect.width / GRID_SIZE); const gridHeight = Math.round(rect.height / GRID_SIZE);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.font = `${14 / scale}px sans-serif`; ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
                    ctx.fillText(`${gridWidth} x ${gridHeight}`, rect.x + rect.width + (5/scale), rect.y + rect.height);
                 }
             } else if (['circle', 'knob'].includes(activeTool)) {
                const radius = Math.hypot(currentPos.x - startPos.x, currentPos.y - startPos.y);
                ctx.beginPath();
                ctx.arc(startPos.x, startPos.y, radius, 0, Math.PI * 2);
                ctx.stroke();
             }
             ctx.restore();
        }
        
        if (isMarqueeSelecting) {
            ctx.save(); ctx.fillStyle = 'rgba(56, 189, 248, 0.2)'; ctx.strokeStyle = 'rgba(56, 189, 248, 0.8)'; ctx.lineWidth = 1 / scale;
            const rect = getMarqueeRect();
            ctx.fillRect(rect.x, rect.y, rect.width, rect.height); ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
            ctx.restore();
        }

        if (connectorPreviewPos && activeTool === 'connector') {
            ctx.save(); ctx.globalAlpha = 0.6; ctx.strokeStyle = '#38bdf8'; ctx.lineWidth = 2 / scale;
            drawElement(ctx, { type: 'connector', x: connectorPreviewPos.x, y: connectorPreviewPos.y, label: '' });
            ctx.restore();
        }

        ctx.restore();
    }
    
    function drawElement(ctx, el, isSelection = false) {
        switch (el.type) {
            case 'rect': ctx.strokeRect(el.x, el.y, el.width, el.height); break;
            case 'line': ctx.beginPath(); ctx.moveTo(el.x1, el.y1); ctx.lineTo(el.x2, el.y2); ctx.stroke(); break;
            case 'circle': ctx.beginPath(); ctx.arc(el.x, el.y, el.radius, 0, Math.PI * 2); ctx.stroke(); break;
            case 'knob': {
                const startAngle = (3 / 4) * Math.PI; // 135 degrees (7:30)
                const endAngle = (1 / 4) * Math.PI;   // 45 degrees (4:30)
                
                // Draw outer arc
                ctx.beginPath();
                ctx.arc(el.x, el.y, el.radius, startAngle, endAngle);
                ctx.stroke();

                // Draw pointer handle in the middle
                const handleRadius = 12.5 / scale;
                ctx.beginPath();
                ctx.arc(el.x, el.y, handleRadius, 0, 2 * Math.PI);
                ctx.fillStyle = isSelection ? '#38bdf8' : '#a0aec0';
                ctx.fill();

                // Draw line from center to handle edge based on value
                const totalAngle = (endAngle - startAngle + 2 * Math.PI) % (2* Math.PI); // 270 degrees
                const valueRatio = el.value / el.maxValue;
                const pointerAngle = startAngle + valueRatio * totalAngle;
                ctx.beginPath();
                ctx.moveTo(el.x, el.y);
                ctx.lineTo(el.x + handleRadius * Math.cos(pointerAngle), el.y + handleRadius * Math.sin(pointerAngle));
                ctx.stroke();

                 // Draw value text
                ctx.font = `${Math.min(14, el.radius * 0.8) / scale}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#a0aec0';
                ctx.fillText(el.value.toFixed(0), el.x, el.y + el.radius * 1.3); // Position text below knob
                break;
            }
            case 'text': ctx.font = el.font || '16px sans-serif'; ctx.textAlign = 'left'; ctx.textBaseline = 'top'; ctx.fillText(el.content, el.x, el.y); break;
            case 'connector':
                if (!isSelection && el.label) {
                    ctx.font = `${12 / scale}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = '#a0aec0';
                    ctx.fillText(el.label, el.x, el.y + 15 / scale);
                }
                const radius = 6 / scale;
                ctx.beginPath(); ctx.arc(el.x, el.y, radius, 0, Math.PI * 2);
                ctx.moveTo(el.x - radius, el.y); ctx.lineTo(el.x + radius, el.y);
                ctx.moveTo(el.x, el.y - radius); ctx.lineTo(el.x, el.y + radius);
                ctx.stroke(); break;
        }
    }
    
    function setActiveTool(toolType) {
        document.querySelector('.tool-item.active')?.classList.remove('active');
        document.querySelector(`.tool-item[data-type="${toolType}"]`)?.classList.add('active');
        activeTool = toolType; selectedElements = []; resizingElement = null; connectorPreviewPos = null;
        updateActionButtonsState(); draw();
    }

    document.querySelectorAll('.tool-item').forEach(btn => btn.addEventListener('click', () => setActiveTool(btn.dataset.type)));

    function updateActionButtonsState() {
        const selectedConnectors = selectedElements.filter(el => el.type === 'connector');
        
        addFunctionBtn.disabled = true; // Disable by default
        if (selectedConnectors.length >= 2) addFunctionBtn.disabled = false;

        rotateBtn.disabled = selectedElements.length === 0;

        // Update modal buttons based on selection
        const isExactlyTwoConnectors = selectedConnectors.length === 2;
        funcCoilBtn.disabled = !isExactlyTwoConnectors;
        funcAContactBtn.disabled = !isExactlyTwoConnectors;
        funcBContactBtn.disabled = !isExactlyTwoConnectors;
        funcConductiveBtn.disabled = selectedConnectors.length < 2;
        const canSetTimedContact = isExactlyTwoConnectors && drawingElements.some(el => el.type === 'knob');
        funcTimedAContactBtn.disabled = !canSetTimedContact;
        funcTimedBContactBtn.disabled = !canSetTimedContact;
    }

    const snapToIntersection = (val) => Math.round(val / GRID_SIZE) * GRID_SIZE;
    const snapToHalfGrid = (val) => Math.round(val / (GRID_SIZE / 2)) * (GRID_SIZE / 2);
    const snapToQuarterGrid = (val) => Math.round(val / (GRID_SIZE / 4)) * (GRID_SIZE / 4);

    
    function getElementAtPos(worldX, worldY) {
        if (resizingElement && getHandleAtPos(worldX, worldY, resizingElement)) return resizingElement;
        
        return [...drawingElements].reverse().find(el => {
            const dist = Math.hypot(el.x - worldX, el.y - worldY);
            switch(el.type) {
                case 'rect': {
                    const tolerance = 5 / scale;
                    const isInsideOuter = worldX >= el.x && worldX <= el.x + el.width && worldY >= el.y && worldY <= el.y + el.height;
                    if (!isInsideOuter) return false;
                    if (el.width < tolerance * 2 || el.height < tolerance * 2) return true;
                    const isInsideInner = worldX > el.x + tolerance && worldX < el.x + el.width - tolerance && worldY > el.y + tolerance && worldY < el.y + el.height - tolerance;
                    return !isInsideInner;
                }
                case 'circle': {
                    const tolerance = 5 / scale;
                    return Math.abs(dist - el.radius) < tolerance;
                }
                case 'knob': {
                    return dist < el.radius + (5 / scale);
                }
                case 'text': 
                    ctx.font = el.font || '16px sans-serif';
                    const textHeight = parseInt(ctx.font) * 1.2;
                    return worldX >= el.x && worldX <= el.x + ctx.measureText(el.content).width && worldY >= el.y && worldY <= el.y + textHeight;
                case 'connector': return dist < 10 / scale;
                case 'line': return pDistance(worldX, worldY, el.x1, el.y1, el.x2, el.y2) < 5 / scale;
            }
            return false;
        });
    }
    
    function getMarqueeRect() {
        return { x: Math.min(startPos.x, currentPos.x), y: Math.min(startPos.y, currentPos.y), width: Math.abs(startPos.x - currentPos.x), height: Math.abs(startPos.y - currentPos.y) };
    }
    
    function pDistance(x, y, x1, y1, x2, y2) {
        const A = x - x1, B = y - y1, C = x2 - x1, D = y2 - y1;
        const dot = A * C + B * D, len_sq = C * C + D * D;
        let param = -1; if (len_sq != 0) param = dot / len_sq;
        let xx, yy;
        if (param < 0) { xx = x1; yy = y1; } else if (param > 1) { xx = x2; yy = y2; } else { xx = x1 + param * C; yy = y1 + param * D; }
        return Math.hypot(x - xx, y - yy);
    }

    canvas.addEventListener('mousedown', e => {
        if (e.button === 1) { // Middle mouse button for panning
            isPanning = true; panStart = { x: e.clientX, y: e.clientY }; canvas.style.cursor = 'grabbing'; e.preventDefault(); return;
        }

        const worldPos = screenToWorld(e.offsetX, e.offsetY);
        startPos = worldPos; currentPos = worldPos;

        if (resizingElement) {
            const handle = getHandleAtPos(startPos.x, startPos.y, resizingElement);
            if (handle) {
                isResizing = true; resizeHandle = handle;
                dragStartPositions.set(resizingElement, { x: resizingElement.x, y: resizingElement.y, width: resizingElement.width, height: resizingElement.height });
                dragOffset = { ...startPos }; return;
            }
            const elBox = resizingElement;
            if (!(startPos.x >= elBox.x && startPos.x <= elBox.x + elBox.width && startPos.y >= elBox.y && startPos.y <= elBox.y + elBox.height)) {
                resizingElement = null;
            } else { selectedElements = [resizingElement]; }
        }
        
        const clickedElement = getElementAtPos(startPos.x, startPos.y);

        if (activeTool === 'select' && clickedElement && clickedElement.type === 'knob') {
            const dist = Math.hypot(worldPos.x - clickedElement.x, worldPos.y - clickedElement.y);
            const handleRadius = 12.5 / scale;
            if (dist < handleRadius) {
                isAdjustingKnob = true;
                adjustingKnob = clickedElement;
                return; // Prevent dragging or selecting
            }
        }

        if (['line', 'rect', 'circle', 'knob'].includes(activeTool)) {
            isDrawing = true; 
            if (activeTool === 'rect') { startPos.x = snapToIntersection(startPos.x); startPos.y = snapToIntersection(startPos.y); } 
            else if (['circle', 'knob'].includes(activeTool)) { startPos.x = snapToQuarterGrid(startPos.x); startPos.y = snapToQuarterGrid(startPos.y); }
            currentPos = { ...startPos };
        } else if (activeTool === 'select') {
            if (clickedElement) {
                if (e.shiftKey) { const index = selectedElements.indexOf(clickedElement); if (index > -1) selectedElements.splice(index, 1); else selectedElements.push(clickedElement); } 
                else if (!selectedElements.includes(clickedElement)) { selectedElements = [clickedElement]; }
                isDragging = true; dragStartPositions.clear();
                selectedElements.forEach(el => dragStartPositions.set(el, {id: el.id, x: el.x, y: el.y, radius: el.radius, x1: el.x1, y1: el.y1, x2: el.x2, y2: el.y2 }));
                dragOffset = { ...startPos };
            } else {
                if (!e.shiftKey) selectedElements = [];
                isMarqueeSelecting = true;
            }
        }
        updateActionButtonsState(); draw();
    });

    canvas.addEventListener('mousemove', e => {
        if (isPanning) {
            const dx = e.clientX - panStart.x;
            const dy = e.clientY - panStart.y;
            viewOffsetX += dx;
            viewOffsetY += dy;
            panStart = { x: e.clientX, y: e.clientY };
            draw();
            return;
        }

        const worldPos = screenToWorld(e.offsetX, e.offsetY);
        currentPos = worldPos;
        let needsRedraw = false, newCursor = 'default';

        if (isAdjustingKnob) {
            const knob = adjustingKnob;
            const dy = currentPos.y - knob.y;
            const dx = currentPos.x - knob.x;
            let angle = Math.atan2(dy, dx);
            
            const startAngle = (3 / 4) * Math.PI; // 135 deg
            const endAngle = (9 / 4) * Math.PI;   // 405 deg

            if (angle < 0) angle += 2 * Math.PI;
            
            // Clamp angle to the allowed range
            const clampedAngle = Math.max(startAngle, Math.min(angle, endAngle));
            
            const totalAngle = endAngle - startAngle;
            const valueRatio = (clampedAngle - startAngle) / totalAngle;
            
            knob.value = Math.round(valueRatio * knob.maxValue); // Round to integer
            needsRedraw = true;
        }
        else if (isResizing && resizingElement) {
            const dx = currentPos.x - dragOffset.x, dy = currentPos.y - dragOffset.y;
            const originalRect = dragStartPositions.get(resizingElement);
            let { x, y, width, height } = originalRect;
            if (resizeHandle.includes('right'))   width = snapToIntersection(originalRect.width + dx);
            if (resizeHandle.includes('bottom'))  height = snapToIntersection(originalRect.height + dy);
            if (resizeHandle.includes('left'))   { const d = snapToIntersection(dx); x = originalRect.x + d; width = originalRect.width - d; }
            if (resizeHandle.includes('top'))    { const d = snapToIntersection(dy); y = originalRect.y + d; height = originalRect.height - d; }
            resizingElement.x = x; resizingElement.y = y; resizingElement.width = width; resizingElement.height = height;
            needsRedraw = true;
        } else if (isDragging) {
            const dx = currentPos.x - dragOffset.x, dy = currentPos.y - dragOffset.y;
            selectedElements.forEach(el => {
                const start = dragStartPositions.get(el);
                if (el.type === 'line') { el.x1 = snapToHalfGrid(start.x1 + dx); el.y1 = snapToHalfGrid(start.y1 + dy); el.x2 = snapToHalfGrid(start.x2 + dx); el.y2 = snapToHalfGrid(start.y2 + dy); } 
                else { el.x = snapToHalfGrid(start.x + dx); el.y = snapToHalfGrid(start.y + dy); }
            });
            needsRedraw = true;
        } else if (isDrawing) {
            if (activeTool === 'line') {
                const dx = currentPos.x - startPos.x, dy = currentPos.y - startPos.y; const angle = Math.atan2(dy, dx), snapAngle = Math.PI / 12;
                const snappedAngle = Math.round(angle / snapAngle) * snapAngle; const dist = Math.hypot(dx, dy);
                currentPos.x = startPos.x + Math.cos(snappedAngle) * dist; currentPos.y = startPos.y + Math.sin(snappedAngle) * dist;
            } else if (activeTool === 'rect') { currentPos.x = snapToIntersection(currentPos.x); currentPos.y = snapToIntersection(currentPos.y); }
            needsRedraw = true;
        } else if (isMarqueeSelecting) needsRedraw = true;

        if (resizingElement && !isResizing) {
            const handle = getHandleAtPos(currentPos.x, currentPos.y, resizingElement);
            if (handle) {
                if (handle.includes('left') || handle.includes('right')) newCursor = 'ew-resize';
                if (handle.includes('top') || handle.includes('bottom')) newCursor = 'ns-resize';
                if ((handle.includes('top') && handle.includes('left')) || (handle.includes('bottom') && handle.includes('right'))) newCursor = 'nwse-resize';
                if ((handle.includes('top') && handle.includes('right')) || (handle.includes('bottom') && handle.includes('left'))) newCursor = 'nesw-resize';
            } else newCursor = 'move';
        }
        if (activeTool === 'connector') { connectorPreviewPos = { x: snapToIntersection(currentPos.x), y: snapToIntersection(currentPos.y) }; needsRedraw = true; } 
        else if (connectorPreviewPos) { connectorPreviewPos = null; needsRedraw = true; }

        canvas.style.cursor = newCursor;
        if(needsRedraw) draw();
    });

    canvas.addEventListener('mouseleave', () => { if(connectorPreviewPos){ connectorPreviewPos = null; draw(); } });
    
    canvas.addEventListener('mouseup', e => {
        if (e.button === 1 && isPanning) {
            isPanning = false; canvas.style.cursor = 'default'; return;
        }
        if (isAdjustingKnob) {
            isAdjustingKnob = false; adjustingKnob = null; return;
        }
        if (isResizing) {
            isResizing = false; resizeHandle = null;
            if (resizingElement.width < 0) { resizingElement.x += resizingElement.width; resizingElement.width *= -1; }
            if (resizingElement.height < 0) { resizingElement.y += resizingElement.height; resizingElement.height *= -1; }
            draw(); return;
        }
        if (isDrawing) {
            isDrawing = false;
            if (activeTool === 'line') {
                const s = {x: snapToHalfGrid(startPos.x), y: snapToHalfGrid(startPos.y) }, c = {x: snapToHalfGrid(currentPos.x), y: snapToHalfGrid(currentPos.y) };
                if (Math.hypot(s.x-c.x, s.y-c.y) > 0) drawingElements.push({ id: ++elementIdCounter, type: 'line', x1: s.x, y1: s.y, x2: c.x, y2: c.y });
            } else if (activeTool === 'rect') {
                const rect = getMarqueeRect();
                if (rect.width > 0 && rect.height > 0) drawingElements.push({ id: ++elementIdCounter, type: 'rect', ...rect });
            } else if (activeTool === 'circle' || activeTool === 'knob') {
                const radius = snapToQuarterGrid(Math.hypot(currentPos.x - startPos.x, currentPos.y - startPos.y));
                if (radius > 0) {
                     if (activeTool === 'circle') {
                        drawingElements.push({ id: ++elementIdCounter, type: 'circle', x: startPos.x, y: startPos.y, radius: radius });
                     } else { // Knob
                        drawingElements.push({ id: ++elementIdCounter, type: 'knob', x: startPos.x, y: startPos.y, radius: radius, value: 0, maxValue: 10 });
                     }
                }
            }
        } else if (isDragging) { isDragging = false; dragStartPositions.clear();
        } else if (isMarqueeSelecting) {
            isMarqueeSelecting = false;
            const marquee = getMarqueeRect();
            drawingElements.filter(el => {
                let elBox;
                if(el.type === 'line') elBox = { x: Math.min(el.x1, el.x2), y: Math.min(el.y1, el.y2), width: Math.abs(el.x1-el.x2), height: Math.abs(el.y1-el.y2) }
                else if (el.type === 'circle' || el.type === 'knob') elBox = { x: el.x - el.radius, y: el.y - el.radius, width: el.radius * 2, height: el.radius * 2 }
                else { const textWidth = el.type === 'text' ? ctx.measureText(el.content).width : (el.width || 0); elBox = { x: el.x, y: el.y, width: textWidth, height: el.height || 16} }
                return marquee.x < elBox.x + elBox.width && marquee.x + marquee.width > elBox.x && marquee.y < elBox.y + elBox.height && marquee.y + marquee.height > elBox.y;
            }).forEach(el => !selectedElements.includes(el) && selectedElements.push(el));
        }
        updateActionButtonsState(); draw();
    });
    
    canvas.addEventListener('click', e => {
         if (isDragging || isMarqueeSelecting || isDrawing || e.detail > 1 || isResizing || isAdjustingKnob) return;
         const clickPos = screenToWorld(e.offsetX, e.offsetY);
         if (activeTool === 'text') {
            const pos = {x: snapToHalfGrid(clickPos.x), y: snapToHalfGrid(clickPos.y)};
            if (!getElementAtPos(clickPos.x, clickPos.y)) {
                 drawingElements.push({ id: ++elementIdCounter, type: 'text', ...pos, content: '文字', font: '16px sans-serif' });
                 setActiveTool('select');
            }
         } else if (activeTool === 'connector') {
             const pos = {x: snapToIntersection(clickPos.x), y: snapToIntersection(clickPos.y)};
             drawingElements.push({ id: ++elementIdCounter, type: 'connector', ...pos, label: '' });
         } else if (activeTool === 'delete') {
             const elToDelete = getElementAtPos(clickPos.x, clickPos.y);
             if (elToDelete) {
                 const deletedIds = new Set([elToDelete.id]);
                 componentFunctions = componentFunctions.filter(func => {
                     const newConnectors = func.connectors.filter(id => !deletedIds.has(id));
                     if (newConnectors.length < 2) return false;
                     func.connectors = newConnectors;
                     return true;
                 });
                 drawingElements = drawingElements.filter(el => el !== elToDelete);
             }
         }
         updateActionButtonsState(); draw();
    });
    
    canvas.addEventListener('dblclick', e => {
        const pos = screenToWorld(e.offsetX, e.offsetY);
        const el = getElementAtPos(pos.x, pos.y);
        if (!el) return;
        if (el.type === 'text') editText(el);
        else if (el.type === 'connector') {
            const newLabel = prompt('請輸入接點標籤:', el.label);
            if (newLabel !== null) { el.label = newLabel.trim(); draw(); }
        } else if (el.type === 'rect') { resizingElement = el; selectedElements = []; draw(); }
        else if (el.type === 'knob') {
            const newMax = prompt('請輸入旋鈕最大值:', el.maxValue);
            const parsedMax = parseInt(newMax);
            if (!isNaN(parsedMax) && parsedMax > 0) {
                el.maxValue = parsedMax;
                if (el.value > el.maxValue) el.value = el.maxValue;
                draw();
            }
        }
    });

    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const mouseX = e.offsetX;
        const mouseY = e.offsetY;
        const worldXBefore = (mouseX - viewOffsetX) / scale;
        const worldYBefore = (mouseY - viewOffsetY) / scale;
        
        const scaleFactor = 1.1;
        if (e.deltaY < 0) { scale *= scaleFactor; } else { scale /= scaleFactor; }
        scale = Math.max(0.2, Math.min(scale, 5));

        viewOffsetX = mouseX - worldXBefore * scale;
        viewOffsetY = mouseY - worldYBefore * scale;
        
        draw();
    });

    function editText(el) {
        editingTextElement = el; selectedElements = [];
        const screenPos = worldToScreen(el.x, el.y);
        textEditor.style.display = 'block';
        textEditor.style.left = `${screenPos.x}px`;
        textEditor.style.top = `${screenPos.y}px`;
        const originalFontSize = parseInt((el.font || '16px').match(/(\d+)px/)[1] || 16);
        textEditor.style.font = el.font;
        textEditor.style.fontSize = `${originalFontSize * scale}px`;
        ctx.font = el.font || '16px sans-serif';
        textEditor.style.width = `${ctx.measureText(el.content).width * scale + 20}px`;
        textEditor.value = el.content;
        textEditor.focus();
        draw();
    }

    textEditor.addEventListener('blur', () => {
        if (editingTextElement) editingTextElement.content = textEditor.value;
        editingTextElement = null; textEditor.style.display = 'none'; draw();
    });
    textEditor.addEventListener('keydown', e => {
        e.stopPropagation();
        if (e.key === 'Enter') { e.preventDefault(); textEditor.blur(); } 
        else if (e.key === 'Escape') { textEditor.value = editingTextElement.content; textEditor.blur(); }
    });

    addFunctionBtn.addEventListener('click', (e) => {
        if (addFunctionBtn.disabled) return;
        updateActionButtonsState(); // Ensure modal buttons are correctly enabled/disabled
        const rect = addFunctionBtn.getBoundingClientRect(); functionModal.classList.remove('hidden');
        const modalRect = functionModal.getBoundingClientRect();
        functionModal.style.left = `${rect.left + (rect.width / 2) - (modalRect.width / 2)}px`;
        functionModal.style.top = `${rect.top - modalRect.height - 10}px`; 
        e.stopPropagation();
    });
    
    rotateBtn.addEventListener('click', () => {
        if (selectedElements.length === 0) return;
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        selectedElements.forEach(el => {
            if (el.type === 'line') { minX = Math.min(minX, el.x1, el.x2); minY = Math.min(minY, el.y1, el.y2); maxX = Math.max(maxX, el.x1, el.x2); maxY = Math.max(maxY, el.y1, el.y2); } 
            else if (el.type === 'rect') { minX = Math.min(minX, el.x); minY = Math.min(minY, el.y); maxX = Math.max(maxX, el.x + el.width); maxY = Math.max(maxY, el.y + el.height); } 
            else if (['circle', 'knob'].includes(el.type)) { minX = Math.min(minX, el.x - el.radius); minY = Math.min(minY, el.y - el.radius); maxX = Math.max(maxX, el.x + el.radius); maxY = Math.max(maxY, el.y + el.radius); }
            else { minX = Math.min(minX, el.x); minY = Math.min(minY, el.y); maxX = Math.max(maxX, el.x); maxY = Math.max(maxY, el.y); }
        });

        const pivotX = (minX + maxX) / 2; const pivotY = (minY + maxY) / 2;
        const rotatePoint = (x, y, ox, oy) => ({ x: ox - (y - oy), y: oy + (x - ox) });

        selectedElements.forEach(el => {
            if (['connector', 'text', 'circle', 'knob'].includes(el.type)) { const newPos = rotatePoint(el.x, el.y, pivotX, pivotY); el.x = snapToHalfGrid(newPos.x); el.y = snapToHalfGrid(newPos.y); } 
            else if (el.type === 'line') { const newP1 = rotatePoint(el.x1, el.y1, pivotX, pivotY); const newP2 = rotatePoint(el.x2, el.y2, pivotX, pivotY); el.x1 = snapToHalfGrid(newP1.x); el.y1 = snapToHalfGrid(newP1.y); el.x2 = snapToHalfGrid(newP2.x); el.y2 = snapToHalfGrid(newP2.y); } 
            else if (el.type === 'rect') { const newCenter = rotatePoint(el.x + el.width / 2, el.y + el.height / 2, pivotX, pivotY); const oldWidth = el.width; el.width = el.height; el.height = oldWidth; el.x = snapToHalfGrid(newCenter.x - el.width / 2); el.y = snapToHalfGrid(newCenter.y - el.height / 2); }
        });
        draw();
    });
    
    function addFunction(type) {
        const selectedConnectors = selectedElements.filter(el => el.type === 'connector');
        
        const isTimed = type.startsWith('timed-');
        
        if (isTimed) {
            if (selectedConnectors.length !== 2) return;
            const firstKnob = drawingElements.find(el => el.type === 'knob');
            if (!firstKnob) return; // Button should be disabled anyway
            const connectorIds = selectedConnectors.map(c => c.id).sort((a,b) => a-b);
            componentFunctions.push({ type, connectors: connectorIds, knobId: firstKnob.id });
        } else if (type === '相通') {
             if (selectedConnectors.length < 2) return;
             const selectedIds = selectedConnectors.map(c => c.id);
             let groupsToMerge = [], remainingFunctions = [];
             const idSet = new Set(selectedIds);
             componentFunctions.forEach(func => {
                 if (func.type === '相通' && func.connectors.some(id => idSet.has(id))) {
                     groupsToMerge.push(func);
                 } else {
                     remainingFunctions.push(func);
                 }
             });
             const mergedIds = new Set(selectedIds);
             groupsToMerge.forEach(group => group.connectors.forEach(id => mergedIds.add(id)));
             componentFunctions = [...remainingFunctions, { type: '相通', connectors: Array.from(mergedIds).sort((a, b) => a - b) }];
        } else { // coil, a-contact, b-contact
            if (selectedConnectors.length !== 2) return;
            const selectedIds = selectedConnectors.map(c => c.id).sort((a,b)=>a-b);
            componentFunctions.push({ type, connectors: selectedIds });
        }

        functionModal.classList.add('hidden'); 
        selectedElements = []; 
        updateActionButtonsState(); 
        draw();
    }

    funcConductiveBtn.addEventListener('click', () => addFunction('相通'));
    funcCoilBtn.addEventListener('click', () => addFunction('coil'));
    funcAContactBtn.addEventListener('click', () => addFunction('a-contact'));
    funcBContactBtn.addEventListener('click', () => addFunction('b-contact'));
    funcTimedAContactBtn.addEventListener('click', () => addFunction('timed-a-contact'));
    funcTimedBContactBtn.addEventListener('click', () => addFunction('timed-b-contact'));


    window.addEventListener('click', (e) => {
        if (!functionModal.classList.contains('hidden') && e.target.id !== 'add-function-btn' && !functionModal.contains(e.target)) {
            functionModal.classList.add('hidden');
        }
    });

    window.addEventListener('keydown', e => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || editingTextElement) return;

        if (e.key === 'Escape') {
            if (['line', 'rect', 'circle', 'knob', 'text', 'connector', 'delete'].includes(activeTool)) {
                 setActiveTool('select');
            }
        }

        if (e.key === 'Delete' || e.key === 'Backspace') {
            if (selectedElements.length > 0) {
                const deletedIds = new Set(selectedElements.map(el => el.id));
                componentFunctions = componentFunctions.map(func => ({...func, connectors: func.connectors.filter(id => !deletedIds.has(id))})).filter(func => func.connectors.length > 1);
                drawingElements = drawingElements.filter(el => !selectedElements.includes(el));
                selectedElements = []; updateActionButtonsState(); draw();
            }
        }
    });

    exportBtn.addEventListener('click', () => {
        if (drawingElements.length === 0) { codeArea.value = "畫布上沒有任何元件可供輸出。"; return; }
        let minX = Infinity, minY = Infinity;
        drawingElements.forEach(el => { 
            if (el.type === 'line') { minX = Math.min(minX, el.x1, el.x2); minY = Math.min(minY, el.y1, el.y2); } 
            else if (['circle', 'knob'].includes(el.type)) { minX = Math.min(minX, el.x - el.radius); minY = Math.min(minY, el.y - el.radius); } 
            else { minX = Math.min(minX, el.x); minY = Math.min(minY, el.y); }
        });

        const connectors = drawingElements.filter(el => el.type === 'connector');
        const knobs = drawingElements.filter(el => el.type === 'knob');
        const connectorIdToLabel = new Map(); let tempConnectorCount = 1;
        connectors.forEach(c => connectorIdToLabel.set(c.id, c.label || `C${tempConnectorCount++}`));
        const knobIdToName = new Map(); let tempKnobCount = 1;
        knobs.forEach(k => knobIdToName.set(k.id, `knob${tempKnobCount++}`));
        
        const dataBlock = `/* --- MAKER DATA ---\n${JSON.stringify({ drawingElements, componentFunctions }, null, 2)}\n--- END MAKER DATA --- */`;
        
        const connectLogic = (labels, prefix = 'c') => {
            if (labels.length < 2) return '';
            const gets = labels.map(l => `const ${prefix}_${l}=this.getConnectorByPole('${l}');`).join('');
            const allConnectors = `[${labels.map(l => `${prefix}_${l}`).join(',')}]`;
            const potentialChecks = labels.map(l => `${prefix}_${l}.potential`).join(',');
            return `{${gets} if(${allConnectors}.every(c=>c)){const potentials=[${potentialChecks}].filter(p=>p>0); const maxPotential=potentials.length>0?Math.max(...potentials):0; if(maxPotential>0){${allConnectors}.forEach(c=>c.potential=maxPotential);}}}`;
        };
        
        let logicCode = `
    // This method is called by the simulation engine on every frame.
    updateLogic(deltaTime) {
        // --- Coil Energization Logic ---
        let isEnergizedCurrentFrame = false;
        ${componentFunctions.filter(f => f.type === 'coil').map(func => {
            const labels = func.connectors.map(id => connectorIdToLabel.get(id)).filter(Boolean);
            if (labels.length !== 2) return '';
            const [l1, l2] = labels;
            return `const coil_c1 = this.getConnectorByPole('${l1}'); const coil_c2 = this.getConnectorByPole('${l2}'); if (coil_c1 && coil_c2 && coil_c1.potential !== coil_c2.potential) { isEnergizedCurrentFrame = true; }`;
        }).join('\n        ')}
        
        const wasEnergized = this.isEnergized;
        this.isEnergized = isEnergizedCurrentFrame;

        // --- Timer Logic ---
        ${componentFunctions.filter(f => f.type.startsWith('timed-')).map(func => {
            const timerName = `timer_${func.knobId}`;
            const knobName = knobIdToName.get(func.knobId);
            return `
        if (this.isEnergized) {
            if (!wasEnergized) { // Just turned on
                this.timers.${timerName}.active = true;
                this.timers.${timerName}.delay = this.knobs.${knobName}.value * 1000;
                this.timers.${timerName}.elapsed = 0;
            }
            if(this.timers.${timerName}.active) {
                this.timers.${timerName}.elapsed += deltaTime;
            }
        } else {
            this.timers.${timerName}.active = false;
            this.timers.${timerName}.elapsed = 0;
        }`;
        }).join('')}

        // --- Contact Logic ---
        // Instantaneous A-Contact (NO)
        if (this.isEnergized) {
            ${componentFunctions.filter(f => f.type === 'a-contact').map(func => connectLogic(func.connectors.map(id => connectorIdToLabel.get(id)), 'ac')).join('\n            ')}
        }
        // Instantaneous B-Contact (NC)
        if (!this.isEnergized) {
             ${componentFunctions.filter(f => f.type === 'b-contact').map(func => connectLogic(func.connectors.map(id => connectorIdToLabel.get(id)), 'bc')).join('\n            ')}
        }
        // Timed A-Contact (NO-T)
        ${componentFunctions.filter(f => f.type === 'timed-a-contact').map(func => {
            const timerName = `timer_${func.knobId}`;
            return `if (this.timers.${timerName}.active && this.timers.${timerName}.elapsed >= this.timers.${timerName}.delay) {
            ${connectLogic(func.connectors.map(id => connectorIdToLabel.get(id)), `tac`)}
        }`;
        }).join('\n        ')}
        // Timed B-Contact (NC-T)
        ${componentFunctions.filter(f => f.type === 'timed-b-contact').map(func => {
            const timerName = `timer_${func.knobId}`;
            return `if (!this.isEnergized || (this.isEnergized && this.timers.${timerName}.elapsed < this.timers.${timerName}.delay)) {
            ${connectLogic(func.connectors.map(id => connectorIdToLabel.get(id)), `tbc`)}
        }`;
        }).join('\n        ')}
        // Simple Conductive Logic
        ${componentFunctions.filter(f => f.type === '相通').map(func => connectLogic(func.connectors.map(id => connectorIdToLabel.get(id)), 'cond')).join('\n        ')}
    }`;
        const drawCode = `draw(ctx) { const baseIsPowered = this.connectors.some(c => c.potential !== 0) || this.isEnergized; ctx.strokeStyle = baseIsPowered ? '#f6e05e' : '#a0aec0'; ctx.fillStyle = ctx.strokeStyle; ctx.lineWidth = 2; ${drawingElements.map(el => { if (el.type === 'connector') return ''; const relX = el.x - minX; const relY = el.y - minY; switch(el.type) { case 'rect': return `ctx.strokeRect(this.x+${relX},this.y+${relY},${el.width},${el.height});`; case 'circle': return `ctx.beginPath();ctx.arc(this.x+${relX},this.y+${relY},${el.radius},0,Math.PI*2);ctx.stroke();`; case 'line': return `ctx.beginPath();ctx.moveTo(this.x+${el.x1 - minX},this.y+${el.y1 - minY});ctx.lineTo(this.x+${el.x2-minX},this.y+${el.y2-minY});ctx.stroke();`; case 'text': return `ctx.font='${el.font}';ctx.fillText(${el.content.includes('(X)') ? `\`${el.content.replaceAll('(X)', `\${this.instanceNumber}`)}\`` : `'${el.content.replace(/'/g, "\\'")}'`},this.x+${relX},this.y+${relY});`; case 'knob': const kName=knobIdToName.get(el.id); return `this.drawKnob(ctx, this.x+${relX}, this.y+${relY}, ${el.radius}, this.knobs.${kName}.value, this.knobs.${kName}.maxValue);`; default: return ''; } }).filter(Boolean).join('')} this.connectors.forEach(c => drawConnector(ctx, c)); }`;

        let fullClassCode = `${dataBlock}\n
class CustomComponent extends Component { 
    static instanceCount=0; 
    constructor(x,y){
        super(x,y,'customComponent');
        this.instanceNumber=++CustomComponent.instanceCount;
        this.isEnergized=false;
        this.knobs = {
            ${knobs.map(k => {
                const kName = knobIdToName.get(k.id);
                return `'${kName}': { value: ${k.value}, maxValue: ${k.maxValue}, x: ${k.x-minX}, y: ${k.y-minY}, radius: ${k.radius} }`;
            }).join(',\n            ')}
        };
        this.timers = {
            ${componentFunctions.filter(f => f.type.startsWith('timed-')).map(func => {
                const timerName = `timer_${func.knobId}`;
                return `'${timerName}': { active: false, elapsed: 0, delay: 0 }`;
            }).filter((v,i,a) => a.indexOf(v)===i).join(',\n            ')}
        };
        this.adjustingKnob = null;

        this._updateDimensions();
        this._rebuildConnectors();
    } 

    _updateDimensions(){
        let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
        const elements=${JSON.stringify(drawingElements)};
        if(elements.length===0){this.width=0;this.height=0;return}
        elements.forEach(el=>{ 
            if (el.type === 'line') { minX = Math.min(minX, el.x1, el.x2); minY = Math.min(minY, el.y1, el.y2); maxX = Math.max(maxX, el.x1, el.x2); maxY = Math.max(maxY, el.y1, el.y2); } 
            else if (el.type === 'rect') { minX = Math.min(minX, el.x); minY = Math.min(minY, el.y); maxX = Math.max(maxX, el.x + el.width); maxY = Math.max(maxY, el.y + el.height); } 
            else if (['circle', 'knob'].includes(el.type)) { minX = Math.min(minX, el.x - el.radius); minY = Math.min(minY, el.y - el.radius); maxX = Math.max(maxX, el.x + el.radius); maxY = Math.max(maxY, el.y + el.radius); } 
            else { minX = Math.min(minX, el.x); minY = Math.min(minY, el.y); maxX = Math.max(maxX, el.x); maxY = Math.max(maxY, el.y); } 
        });
        this.width=Math.ceil((maxX-minX)/${GRID_SIZE})*${GRID_SIZE};
        this.height=Math.ceil((maxY-minY)/${GRID_SIZE})*${GRID_SIZE};
    } 

    getConnectorByPole(pole){ return this.connectors.find(c=>c.pole===pole); } 

    _rebuildConnectors() { this.connectors = []; ${connectors.map(c => `this.connectors.push({ id: \`\${this.id}-${connectorIdToLabel.get(c.id)}\`, parent: this, x: this.x + ${c.x - minX}, y: this.y + ${c.y - minY}, type: 'default', pole: '${connectorIdToLabel.get(c.id)}', potential: 0 });`).join('')}} 
    
    drawKnob(ctx, x, y, radius, value, maxValue) {
        const startAngle = (3 / 4) * Math.PI;
        const endAngle = (9 / 4) * Math.PI;
        
        ctx.save();
        ctx.beginPath();
        ctx.arc(x, y, radius, startAngle, endAngle);
        ctx.stroke();

        const handleRadius = 12.5;
        ctx.beginPath();
        ctx.arc(x, y, handleRadius, 0, 2 * Math.PI);
        ctx.fillStyle = '#a0aec0';
        ctx.fill();
        
        const totalAngle = endAngle - startAngle;
        const valueRatio = value / maxValue;
        const pointerAngle = startAngle + valueRatio * totalAngle;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + handleRadius * Math.cos(pointerAngle), y + handleRadius * Math.sin(pointerAngle));
        ctx.stroke();

        ctx.font = \`\${Math.min(14, radius * 0.8)}px sans-serif\`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(value.toFixed(0), x, y - radius - 10);
        ctx.restore();
    }

    ${drawCode} 

    ${logicCode}

    // --- Interaction Logic (for simulation environment) ---
    onMouseDown(localX, localY) {
        for (const key in this.knobs) {
            const knob = this.knobs[key];
            const dist = Math.hypot(localX - (knob.x + this.x), localY - (knob.y + this.y));
            if (dist < 12.5) { // Click on handle
                this.adjustingKnob = key;
                return true; // Event handled
            }
        }
        return false;
    }

    onMouseMove(localX, localY) {
        if (!this.adjustingKnob) return false;
        const knob = this.knobs[this.adjustingKnob];
        const dy = localY - (knob.y + this.y);
        const dx = localX - (knob.x + this.x);
        let angle = Math.atan2(dy, dx);
        
        const startAngle = (3 / 4) * Math.PI;
        const endAngle = (9 / 4) * Math.PI;

        if (angle < startAngle - Math.PI) { angle += 2 * Math.PI; }
        
        const clampedAngle = Math.max(startAngle, Math.min(angle, endAngle));
        const totalAngle = endAngle - startAngle;
        const valueRatio = (clampedAngle - startAngle) / totalAngle;
        
        knob.value = Math.round(valueRatio * knob.maxValue);
        return true;
    }

    onMouseUp() {
        if (!this.adjustingKnob) return false;
        this.adjustingKnob = null;
        return true;
    }
}`;
        codeArea.value = fullClassCode;

        try { codeArea.focus(); codeArea.select(); const successful = document.execCommand('copy'); const originalText = exportBtn.innerHTML; if (successful) { exportBtn.innerHTML = '✅ 已複製!'; } else { exportBtn.innerHTML = '❌ 複製失敗'; } setTimeout(() => { exportBtn.innerHTML = originalText; }, 2000); } catch (err) { console.error('複製時發生錯誤:', err); const originalText = exportBtn.innerHTML; exportBtn.innerHTML = '❌ 複製失敗'; setTimeout(() => { exportBtn.innerHTML = originalText; }, 2000); }
        window.getSelection()?.removeAllRanges();
    });

    loadBtn.addEventListener('click', () => {
        const code = codeArea.value; const dataRegex = /\/\* --- MAKER DATA ---\s*(\{[\s\S]*?\})\s*--- END MAKER DATA --- \*\//; const match = code.match(dataRegex);
        const showFeedback = (btn, msg, isError) => { const originalText = btn.innerHTML, originalClass = btn.className; btn.innerHTML = msg; btn.className = isError ? originalClass.replace(/bg-teal-600/g, 'bg-red-600').replace(/hover:bg-teal-500/g, 'hover:bg-red-500') : originalClass.replace(/bg-teal-600/g, 'bg-green-600').replace(/hover:bg-teal-500/g, 'hover:bg-green-500'); setTimeout(() => { btn.innerHTML = originalText; btn.className = originalClass; }, 2500); };
        if (!match || !match[1]) { console.error('找不到有效的元件資料。'); showFeedback(loadBtn, '❌ 讀取失敗', true); return; }
        try { const data = JSON.parse(match[1]); if (!data.drawingElements || !data.componentFunctions) throw new Error('資料格式不完整。'); drawingElements = data.drawingElements; componentFunctions = data.componentFunctions; elementIdCounter = drawingElements.reduce((maxId, el) => Math.max(maxId, el.id || 0), 0); selectedElements = []; editingTextElement = null; resizingElement = null; showFeedback(loadBtn, '✅ 讀取成功!', false); draw(); } catch (error) { console.error('讀取程式碼失敗:', error); showFeedback(loadBtn, '❌ 格式錯誤', true); }
    });

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    updateActionButtonsState();
</script>
</body>
</html>

