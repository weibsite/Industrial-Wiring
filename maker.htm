<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…ƒä»¶è£½ä½œå™¨</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', 'å¾®è»Ÿæ­£é»‘é«”', sans-serif;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        canvas {
            background-color: #1a202c; /* Dark Blue */
            cursor: default;
        }
        .tool-item.active {
            @apply bg-blue-600 ring-2 ring-blue-300;
        }
        #code-area {
            font-family: 'Courier New', Courier, monospace;
            white-space: pre;
            background-color: #2d3748;
            color: #a0aec0;
            border-radius: 8px;
            padding: 1rem;
            font-size: 14px;
            line-height: 1.5;
            overflow-x: auto;
            border: 1px solid #4a5568;
        }
        #text-editor {
            position: absolute;
            display: none;
            background-color: #4a5568;
            color: white;
            border: 1px solid #a0aec0;
            padding: 2px;
            font-family: 'Inter', 'å¾®è»Ÿæ­£é»‘é«”', sans-serif;
            z-index: 100;
        }
        button:disabled {
            @apply opacity-50 cursor-not-allowed;
        }
    </style>
</head>
<body class="bg-gray-800 text-white h-screen flex flex-col md:flex-row overflow-hidden">

    <!-- Main Content -->
    <div class="flex-1 flex flex-col p-4 gap-4">
        <h1 class="text-2xl font-bold text-center">å…ƒä»¶è£½ä½œå™¨</h1>
        <div id="canvas-wrapper" class="flex-1 bg-gray-700 rounded-lg overflow-hidden shadow-lg relative">
            <canvas id="canvas"></canvas>
            <input type="text" id="text-editor" />
        </div>
    </div>

    <!-- Toolbar & Output -->
    <div class="w-full md:w-96 bg-gray-900 p-4 flex flex-col gap-4 overflow-y-auto">
        <div>
            <h2 class="text-xl font-bold mb-2">å·¥å…·åˆ—</h2>
            <div class="grid grid-cols-2 gap-2">
                <button class="tool-item bg-gray-700 hover:bg-gray-600 p-2 rounded active" data-type="select">ç§»å‹•/é¸å–</button>
                <button class="tool-item bg-gray-700 hover:bg-gray-600 p-2 rounded" data-type="line">ç•«ç·š</button>
                <button class="tool-item bg-gray-700 hover:bg-gray-600 p-2 rounded" data-type="rect">ç•«çŸ©å½¢</button>
                <button class="tool-item bg-gray-700 hover:bg-gray-600 p-2 rounded" data-type="text">æ–‡å­—</button>
                <button class="tool-item bg-green-700 hover:bg-green-600 p-2 rounded" data-type="connector">æ¥é»</button>
                <button class="tool-item bg-red-700 hover:bg-red-600 p-2 rounded" data-type="delete">åˆªé™¤</button>
            </div>
        </div>

        <div class="flex flex-col gap-2">
            <button id="add-function-btn" class="w-full bg-purple-600 hover:bg-purple-500 p-3 rounded-lg font-bold text-lg shadow-md">æ–°å¢åŠŸèƒ½</button>
            <button id="rotate-btn" class="w-full bg-yellow-600 hover:bg-yellow-500 p-3 rounded-lg font-bold text-lg shadow-md">æ—‹è½‰ 90Â°</button>
            <div class="grid grid-cols-2 gap-2 mt-2">
                 <button id="export-btn" class="w-full bg-blue-600 hover:bg-blue-500 p-3 rounded-lg font-bold shadow-md">ğŸš€ ç”¢ç”Ÿ</button>
                 <button id="load-btn" class="w-full bg-teal-600 hover:bg-teal-500 p-3 rounded-lg font-bold shadow-md">ğŸ“¥ è®€å–</button>
            </div>
        </div>
        
        <div class="flex-1 flex flex-col min-h-0">
             <h2 class="text-xl font-bold mb-2">ç¨‹å¼ç¢¼</h2>
             <div id="code-output-container" class="flex-1 min-h-0">
                <textarea id="code-area" class="w-full h-full" spellcheck="false">é»æ“Šã€Œç”¢ç”Ÿã€ä»¥ç”¢ç”Ÿç¨‹å¼ç¢¼...</textarea>
             </div>
        </div>
    </div>
    
    <!-- Function Modal -->
    <div id="function-modal" class="hidden absolute z-50 bg-gray-700 rounded-lg shadow-xl p-4 w-64 border border-gray-500">
        <h3 class="text-lg font-bold mb-4 text-white">é¸æ“‡åŠŸèƒ½</h3>
        <div class="flex flex-col gap-2">
            <button id="func-conductive-btn" class="w-full text-left bg-gray-600 hover:bg-gray-500 p-2 rounded text-white">ç›¸é€š</button>
            <button id="func-coil-btn" class="w-full text-left bg-blue-600 hover:bg-blue-500 p-2 rounded text-white">ç·šåœˆ</button>
            <button id="func-a-contact-btn" class="w-full text-left bg-green-600 hover:bg-green-500 p-2 rounded text-white">Aæ¥é» (NO)</button>
            <button id="func-b-contact-btn" class="w-full text-left bg-red-600 hover:bg-red-500 p-2 rounded text-white">Bæ¥é» (NC)</button>
        </div>
    </div>


<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const canvasWrapper = document.getElementById('canvas-wrapper');
    const textEditor = document.getElementById('text-editor');
    const exportBtn = document.getElementById('export-btn');
    const loadBtn = document.getElementById('load-btn');
    const addFunctionBtn = document.getElementById('add-function-btn');
    const rotateBtn = document.getElementById('rotate-btn');
    const codeArea = document.getElementById('code-area');
    const functionModal = document.getElementById('function-modal');
    const funcConductiveBtn = document.getElementById('func-conductive-btn');
    const funcCoilBtn = document.getElementById('func-coil-btn');
    const funcAContactBtn = document.getElementById('func-a-contact-btn');
    const funcBContactBtn = document.getElementById('func-b-contact-btn');

    const GRID_SIZE = 20;
    const HANDLE_SIZE = 8;
    let drawingElements = [];
    let componentFunctions = [];
    let elementIdCounter = 0;
    let activeTool = 'select';
    let selectedElements = [];
    let editingTextElement = null;
    let connectorPreviewPos = null;
    
    let isDrawing = false;
    let isDragging = false;
    let isMarqueeSelecting = false;
    let isResizing = false;
    let isPanning = false;
    let resizingElement = null;
    let resizeHandle = null;
    let startPos = {x:0, y:0};
    let currentPos = {x:0, y:0};
    let dragOffset = {x:0, y:0};
    let dragStartPositions = new Map();
    let panStart = {x: 0, y: 0};

    let scale = 1;
    let viewOffsetX = 0;
    let viewOffsetY = 0;

    // --- Coordinate Transformation ---
    function screenToWorld(x, y) {
        return { x: (x - viewOffsetX) / scale, y: (y - viewOffsetY) / scale };
    }
    function worldToScreen(x, y) {
        return { x: x * scale + viewOffsetX, y: y * scale + viewOffsetY };
    }

    function resizeCanvas() {
        const container = canvas.parentElement;
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        draw();
    }

    function drawGrid() {
        ctx.strokeStyle = `rgba(255, 255, 255, ${Math.max(0.1, 0.2 / scale)})`;
        ctx.lineWidth = 0.5 / scale;
        const viewLeft = -viewOffsetX / scale;
        const viewTop = -viewOffsetY / scale;
        const viewRight = (canvas.width - viewOffsetX) / scale;
        const viewBottom = (canvas.height - viewOffsetY) / scale;
        const startX = Math.floor(viewLeft / GRID_SIZE) * GRID_SIZE;
        const startY = Math.floor(viewTop / GRID_SIZE) * GRID_SIZE;

        for (let x = startX; x < viewRight; x += GRID_SIZE) {
            ctx.beginPath(); ctx.moveTo(x, viewTop); ctx.lineTo(x, viewBottom); ctx.stroke();
        }
        for (let y = startY; y < viewBottom; y += GRID_SIZE) {
            ctx.beginPath(); ctx.moveTo(viewLeft, y); ctx.lineTo(viewRight, y); ctx.stroke();
        }
    }

    function getResizeHandles(el) {
        if (!el || el.type !== 'rect') return {};
        const { x, y, width: w, height: h } = el;
        const hs = (HANDLE_SIZE / 2) / scale;
        return {
            'top-left':     { x: x - hs, y: y - hs, width: HANDLE_SIZE / scale, height: HANDLE_SIZE / scale }, 'top': { x: x + w/2 - hs, y: y - hs, width: HANDLE_SIZE / scale, height: HANDLE_SIZE / scale }, 'top-right': { x: x + w - hs, y: y - hs, width: HANDLE_SIZE / scale, height: HANDLE_SIZE / scale },
            'left':         { x: x - hs, y: y + h/2 - hs, width: HANDLE_SIZE / scale, height: HANDLE_SIZE / scale }, 'right': { x: x + w - hs, y: y + h/2 - hs, width: HANDLE_SIZE / scale, height: HANDLE_SIZE / scale },
            'bottom-left':  { x: x - hs, y: y + h - hs, width: HANDLE_SIZE / scale, height: HANDLE_SIZE / scale }, 'bottom': { x: x + w/2 - hs, y: y + h - hs, width: HANDLE_SIZE / scale, height: HANDLE_SIZE / scale }, 'bottom-right': { x: x + w - hs, y: y + h - hs, width: HANDLE_SIZE / scale, height: HANDLE_SIZE / scale },
        };
    }

    function getHandleAtPos(posX, posY, el) {
        const handles = getResizeHandles(el);
        for (const name in handles) {
            const h = handles[name];
            if (posX >= h.x && posX <= h.x + h.width && posY >= h.y && posY <= h.y + h.height) return name;
        }
        return null;
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(viewOffsetX, viewOffsetY);
        ctx.scale(scale, scale);

        drawGrid();
        const defaultColor = '#f6e05e';

        componentFunctions.forEach(func => {
            let color = null;
            let dash = [3, 3];
            switch(func.type) {
                case 'ç›¸é€š': color = '#f472b6'; break;
                case 'coil': color = '#60a5fa'; dash = [4,4]; break;
                case 'a-contact': color = '#4ade80'; dash = [4,4]; break;
                case 'b-contact': color = '#f87171'; dash = [4,4]; break;
            }

            if (color) {
                const connectorsInGroup = func.connectors.map(id => drawingElements.find(el => el.id === id)).filter(Boolean);
                if (connectorsInGroup.length > 1) {
                    ctx.save(); ctx.strokeStyle = color; ctx.setLineDash(dash.map(d => d / scale)); ctx.lineWidth = 1.5 / scale;
                     for (let i = 0; i < connectorsInGroup.length; i++) {
                        for (let j = i + 1; j < connectorsInGroup.length; j++) {
                           ctx.beginPath();
                           ctx.moveTo(connectorsInGroup[i].x, connectorsInGroup[i].y);
                           ctx.lineTo(connectorsInGroup[j].x, connectorsInGroup[j].y);
                           ctx.stroke();
                        }
                     }
                    ctx.restore();
                }
            }
        });

        drawingElements.forEach(el => {
            if (el === editingTextElement) return;
            ctx.save(); ctx.strokeStyle = defaultColor; ctx.lineWidth = 2 / scale; ctx.fillStyle = defaultColor;
            drawElement(ctx, el);
            ctx.restore();
        });
        
        if (selectedElements.length > 0) {
            ctx.save(); ctx.strokeStyle = '#38bdf8'; ctx.lineWidth = 2 / scale; ctx.shadowColor = '#38bdf8'; ctx.shadowBlur = 8 / scale;
            selectedElements.forEach(el => drawElement(ctx, el, true));
            ctx.restore();
        }

        if (resizingElement) {
            ctx.save(); ctx.fillStyle = '#38bdf8';
            const handles = getResizeHandles(resizingElement);
            for (const handle in handles) ctx.fillRect(handles[handle].x, handles[handle].y, handles[handle].width, handles[handle].height);
            ctx.restore();
        }

        if (isDrawing) {
             ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 2 / scale; ctx.setLineDash([5 / scale, 5 / scale]);
             if (activeTool === 'line') {
                 ctx.beginPath(); ctx.moveTo(startPos.x, startPos.y); ctx.lineTo(currentPos.x, currentPos.y); ctx.stroke();
             } else if (activeTool === 'rect') {
                 const rect = getMarqueeRect();
                 ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
                 if (rect.width > 0 && rect.height > 0) {
                    const gridWidth = Math.round(rect.width / GRID_SIZE); const gridHeight = Math.round(rect.height / GRID_SIZE);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.font = `${14 / scale}px sans-serif`; ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
                    ctx.fillText(`${gridWidth} x ${gridHeight}`, rect.x + rect.width + (5/scale), rect.y + rect.height);
                 }
             }
             ctx.restore();
        }
        
        if (isMarqueeSelecting) {
            ctx.save(); ctx.fillStyle = 'rgba(56, 189, 248, 0.2)'; ctx.strokeStyle = 'rgba(56, 189, 248, 0.8)'; ctx.lineWidth = 1 / scale;
            const rect = getMarqueeRect();
            ctx.fillRect(rect.x, rect.y, rect.width, rect.height); ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
            ctx.restore();
        }

        if (connectorPreviewPos && activeTool === 'connector') {
            ctx.save(); ctx.globalAlpha = 0.6; ctx.strokeStyle = '#38bdf8'; ctx.lineWidth = 2 / scale;
            drawElement(ctx, { type: 'connector', x: connectorPreviewPos.x, y: connectorPreviewPos.y, label: '' });
            ctx.restore();
        }

        ctx.restore();
    }
    
    function drawElement(ctx, el, isSelection = false) {
        switch (el.type) {
            case 'rect': ctx.strokeRect(el.x, el.y, el.width, el.height); break;
            case 'line': ctx.beginPath(); ctx.moveTo(el.x1, el.y1); ctx.lineTo(el.x2, el.y2); ctx.stroke(); break;
            case 'text': ctx.font = el.font || '16px sans-serif'; ctx.textAlign = 'left'; ctx.textBaseline = 'top'; ctx.fillText(el.content, el.x, el.y); break;
            case 'connector':
                if (!isSelection && el.label) {
                    ctx.font = `${12 / scale}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = '#a0aec0';
                    ctx.fillText(el.label, el.x, el.y + 15 / scale);
                }
                const radius = 6 / scale;
                ctx.beginPath(); ctx.arc(el.x, el.y, radius, 0, Math.PI * 2);
                ctx.moveTo(el.x - radius, el.y); ctx.lineTo(el.x + radius, el.y);
                ctx.moveTo(el.x, el.y - radius); ctx.lineTo(el.x, el.y + radius);
                ctx.stroke(); break;
        }
    }
    
    function setActiveTool(toolType) {
        document.querySelector('.tool-item.active')?.classList.remove('active');
        document.querySelector(`.tool-item[data-type="${toolType}"]`)?.classList.add('active');
        activeTool = toolType; selectedElements = []; resizingElement = null; connectorPreviewPos = null;
        updateActionButtonsState(); draw();
    }

    document.querySelectorAll('.tool-item').forEach(btn => btn.addEventListener('click', () => setActiveTool(btn.dataset.type)));

    function updateActionButtonsState() {
        const selectedConnectors = selectedElements.filter(el => el.type === 'connector');
        addFunctionBtn.disabled = selectedConnectors.length < 2;
        rotateBtn.disabled = selectedElements.length === 0;

        // Update modal buttons based on selection
        const isExactlyTwo = selectedConnectors.length === 2;
        funcCoilBtn.disabled = !isExactlyTwo;
        funcAContactBtn.disabled = !isExactlyTwo;
        funcBContactBtn.disabled = !isExactlyTwo;
        funcConductiveBtn.disabled = selectedConnectors.length < 2;
    }

    const snapToIntersection = (val) => Math.round(val / GRID_SIZE) * GRID_SIZE;
    const snapToHalfGrid = (val) => Math.round(val / (GRID_SIZE / 2)) * (GRID_SIZE / 2);
    
    function getElementAtPos(worldX, worldY) {
        if (resizingElement && getHandleAtPos(worldX, worldY, resizingElement)) return resizingElement;
        
        return [...drawingElements].reverse().find(el => {
            switch(el.type) {
                case 'rect': {
                    const tolerance = 5 / scale;
                    const isInsideOuter = worldX >= el.x && worldX <= el.x + el.width && worldY >= el.y && worldY <= el.y + el.height;
                    if (!isInsideOuter) return false;
                    if (el.width < tolerance * 2 || el.height < tolerance * 2) return true;
                    const isInsideInner = worldX > el.x + tolerance && worldX < el.x + el.width - tolerance && worldY > el.y + tolerance && worldY < el.y + el.height - tolerance;
                    return !isInsideInner;
                }
                case 'text': 
                    ctx.font = el.font || '16px sans-serif';
                    const textHeight = parseInt(ctx.font) * 1.2;
                    return worldX >= el.x && worldX <= el.x + ctx.measureText(el.content).width && worldY >= el.y && worldY <= el.y + textHeight;
                case 'connector': return Math.hypot(el.x - worldX, el.y - worldY) < 10 / scale;
                case 'line': return pDistance(worldX, worldY, el.x1, el.y1, el.x2, el.y2) < 5 / scale;
            }
            return false;
        });
    }
    
    function getMarqueeRect() {
        return { x: Math.min(startPos.x, currentPos.x), y: Math.min(startPos.y, currentPos.y), width: Math.abs(startPos.x - currentPos.x), height: Math.abs(startPos.y - currentPos.y) };
    }
    
    function pDistance(x, y, x1, y1, x2, y2) {
        const A = x - x1, B = y - y1, C = x2 - x1, D = y2 - y1;
        const dot = A * C + B * D, len_sq = C * C + D * D;
        let param = -1; if (len_sq != 0) param = dot / len_sq;
        let xx, yy;
        if (param < 0) { xx = x1; yy = y1; } else if (param > 1) { xx = x2; yy = y2; } else { xx = x1 + param * C; yy = y1 + param * D; }
        return Math.hypot(x - xx, y - yy);
    }

    canvas.addEventListener('mousedown', e => {
        if (e.button === 1) { // Middle mouse button for panning
            isPanning = true; panStart = { x: e.clientX, y: e.clientY }; canvas.style.cursor = 'grabbing'; e.preventDefault(); return;
        }

        const worldPos = screenToWorld(e.offsetX, e.offsetY);
        startPos = worldPos; currentPos = worldPos;

        if (resizingElement) {
            const handle = getHandleAtPos(startPos.x, startPos.y, resizingElement);
            if (handle) {
                isResizing = true; resizeHandle = handle;
                dragStartPositions.set(resizingElement, { x: resizingElement.x, y: resizingElement.y, width: resizingElement.width, height: resizingElement.height });
                dragOffset = { ...startPos }; return;
            }
            const elBox = resizingElement;
            if (!(startPos.x >= elBox.x && startPos.x <= elBox.x + elBox.width && startPos.y >= elBox.y && startPos.y <= elBox.y + elBox.height)) {
                resizingElement = null;
            } else { selectedElements = [resizingElement]; }
        }

        if (['line', 'rect'].includes(activeTool)) {
            isDrawing = true; if (activeTool === 'rect') { startPos.x = snapToIntersection(startPos.x); startPos.y = snapToIntersection(startPos.y); } currentPos = { ...startPos };
        } else if (activeTool === 'select') {
            const clickedElement = getElementAtPos(startPos.x, startPos.y);
            if (clickedElement) {
                if (e.shiftKey) { const index = selectedElements.indexOf(clickedElement); if (index > -1) selectedElements.splice(index, 1); else selectedElements.push(clickedElement); } 
                else if (!selectedElements.includes(clickedElement)) { selectedElements = [clickedElement]; }
                isDragging = true; dragStartPositions.clear();
                selectedElements.forEach(el => dragStartPositions.set(el, {id: el.id, x: el.x, y: el.y, x1: el.x1, y1: el.y1, x2: el.x2, y2: el.y2 }));
                dragOffset = { ...startPos };
            } else {
                if (!e.shiftKey) selectedElements = [];
                isMarqueeSelecting = true;
            }
        }
        updateActionButtonsState(); draw();
    });

    canvas.addEventListener('mousemove', e => {
        if (isPanning) {
            const dx = e.clientX - panStart.x;
            const dy = e.clientY - panStart.y;
            viewOffsetX += dx;
            viewOffsetY += dy;
            panStart = { x: e.clientX, y: e.clientY };
            draw();
            return;
        }

        const worldPos = screenToWorld(e.offsetX, e.offsetY);
        currentPos = worldPos;
        let needsRedraw = false, newCursor = 'default';

        if (isResizing && resizingElement) {
            const dx = currentPos.x - dragOffset.x, dy = currentPos.y - dragOffset.y;
            const originalRect = dragStartPositions.get(resizingElement);
            let { x, y, width, height } = originalRect;
            if (resizeHandle.includes('right'))   width = snapToIntersection(originalRect.width + dx);
            if (resizeHandle.includes('bottom'))  height = snapToIntersection(originalRect.height + dy);
            if (resizeHandle.includes('left'))   { const d = snapToIntersection(dx); x = originalRect.x + d; width = originalRect.width - d; }
            if (resizeHandle.includes('top'))    { const d = snapToIntersection(dy); y = originalRect.y + d; height = originalRect.height - d; }
            resizingElement.x = x; resizingElement.y = y; resizingElement.width = width; resizingElement.height = height;
            needsRedraw = true;
        } else if (isDragging) {
            const dx = currentPos.x - dragOffset.x, dy = currentPos.y - dragOffset.y;
            selectedElements.forEach(el => {
                const start = dragStartPositions.get(el);
                if (el.type === 'line') { el.x1 = snapToHalfGrid(start.x1 + dx); el.y1 = snapToHalfGrid(start.y1 + dy); el.x2 = snapToHalfGrid(start.x2 + dx); el.y2 = snapToHalfGrid(start.y2 + dy); } 
                else { el.x = snapToHalfGrid(start.x + dx); el.y = snapToHalfGrid(start.y + dy); }
            });
            needsRedraw = true;
        } else if (isDrawing) {
            if (activeTool === 'line') {
                const dx = currentPos.x - startPos.x, dy = currentPos.y - startPos.y; const angle = Math.atan2(dy, dx), snapAngle = Math.PI / 12;
                const snappedAngle = Math.round(angle / snapAngle) * snapAngle; const dist = Math.hypot(dx, dy);
                currentPos.x = startPos.x + Math.cos(snappedAngle) * dist; currentPos.y = startPos.y + Math.sin(snappedAngle) * dist;
            } else if (activeTool === 'rect') { currentPos.x = snapToIntersection(currentPos.x); currentPos.y = snapToIntersection(currentPos.y); }
            needsRedraw = true;
        } else if (isMarqueeSelecting) needsRedraw = true;

        if (resizingElement && !isResizing) {
            const handle = getHandleAtPos(currentPos.x, currentPos.y, resizingElement);
            if (handle) {
                if (handle.includes('left') || handle.includes('right')) newCursor = 'ew-resize';
                if (handle.includes('top') || handle.includes('bottom')) newCursor = 'ns-resize';
                if ((handle.includes('top') && handle.includes('left')) || (handle.includes('bottom') && handle.includes('right'))) newCursor = 'nwse-resize';
                if ((handle.includes('top') && handle.includes('right')) || (handle.includes('bottom') && handle.includes('left'))) newCursor = 'nesw-resize';
            } else newCursor = 'move';
        }
        if (activeTool === 'connector') { connectorPreviewPos = { x: snapToIntersection(currentPos.x), y: snapToIntersection(currentPos.y) }; needsRedraw = true; } 
        else if (connectorPreviewPos) { connectorPreviewPos = null; needsRedraw = true; }

        canvas.style.cursor = newCursor;
        if(needsRedraw) draw();
    });

    canvas.addEventListener('mouseleave', () => { if(connectorPreviewPos){ connectorPreviewPos = null; draw(); } });
    
    canvas.addEventListener('mouseup', e => {
        if (e.button === 1 && isPanning) {
            isPanning = false;
            canvas.style.cursor = 'default';
            return;
        }

        if (isResizing) {
            isResizing = false; resizeHandle = null;
            if (resizingElement.width < 0) { resizingElement.x += resizingElement.width; resizingElement.width *= -1; }
            if (resizingElement.height < 0) { resizingElement.y += resizingElement.height; resizingElement.height *= -1; }
            draw(); return;
        }
        if (isDrawing) {
            isDrawing = false;
            if (activeTool === 'line') {
                const s = {x: snapToHalfGrid(startPos.x), y: snapToHalfGrid(startPos.y) }, c = {x: snapToHalfGrid(currentPos.x), y: snapToHalfGrid(currentPos.y) };
                drawingElements.push({ id: ++elementIdCounter, type: 'line', x1: s.x, y1: s.y, x2: c.x, y2: c.y });
            } else if (activeTool === 'rect') {
                const rect = getMarqueeRect();
                if (rect.width > 0 && rect.height > 0) drawingElements.push({ id: ++elementIdCounter, type: 'rect', ...rect });
            }
        } else if (isDragging) { isDragging = false; dragStartPositions.clear();
        } else if (isMarqueeSelecting) {
            isMarqueeSelecting = false;
            const marquee = getMarqueeRect();
            drawingElements.filter(el => {
                let elBox;
                if(el.type === 'line') elBox = { x: Math.min(el.x1, el.x2), y: Math.min(el.y1, el.y2), width: Math.abs(el.x1-el.x2), height: Math.abs(el.y1-el.y2) }
                else { const textWidth = el.type === 'text' ? ctx.measureText(el.content).width : (el.width || 0); elBox = { x: el.x, y: el.y, width: textWidth, height: el.height || 16} }
                return marquee.x < elBox.x + elBox.width && marquee.x + marquee.width > elBox.x && marquee.y < elBox.y + elBox.height && marquee.y + marquee.height > elBox.y;
            }).forEach(el => !selectedElements.includes(el) && selectedElements.push(el));
        }
        updateActionButtonsState(); draw();
    });
    
    canvas.addEventListener('click', e => {
         if (isDragging || isMarqueeSelecting || isDrawing || e.detail > 1 || isResizing) return;
         const clickPos = screenToWorld(e.offsetX, e.offsetY);
         if (activeTool === 'text') {
            const pos = {x: snapToHalfGrid(clickPos.x), y: snapToHalfGrid(clickPos.y)};
            if (!getElementAtPos(clickPos.x, clickPos.y)) {
                 drawingElements.push({ id: ++elementIdCounter, type: 'text', ...pos, content: 'æ–‡å­—', font: '16px sans-serif' });
                 setActiveTool('select');
            }
         } else if (activeTool === 'connector') {
             const pos = {x: snapToIntersection(clickPos.x), y: snapToIntersection(clickPos.y)};
             drawingElements.push({ id: ++elementIdCounter, type: 'connector', ...pos, label: '' });
         } else if (activeTool === 'delete') {
             const elToDelete = getElementAtPos(clickPos.x, clickPos.y);
             if (elToDelete) {
                 const deletedIds = new Set([elToDelete.id]);
                 componentFunctions = componentFunctions.filter(func => {
                     const newConnectors = func.connectors.filter(id => !deletedIds.has(id));
                     if (newConnectors.length < 2) return false;
                     func.connectors = newConnectors;
                     return true;
                 });
                 drawingElements = drawingElements.filter(el => el !== elToDelete);
             }
         }
         updateActionButtonsState(); draw();
    });
    
    canvas.addEventListener('dblclick', e => {
        const pos = screenToWorld(e.offsetX, e.offsetY);
        const el = getElementAtPos(pos.x, pos.y);
        if (!el) return;
        if (el.type === 'text') editText(el);
        else if (el.type === 'connector') {
            const newLabel = prompt('è«‹è¼¸å…¥æ¥é»æ¨™ç±¤:', el.label);
            if (newLabel !== null) { el.label = newLabel.trim(); draw(); }
        } else if (el.type === 'rect') { resizingElement = el; selectedElements = []; draw(); }
    });

    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const mouseX = e.offsetX;
        const mouseY = e.offsetY;
        const worldXBefore = (mouseX - viewOffsetX) / scale;
        const worldYBefore = (mouseY - viewOffsetY) / scale;
        
        const scaleFactor = 1.1;
        if (e.deltaY < 0) { scale *= scaleFactor; } else { scale /= scaleFactor; }
        scale = Math.max(0.2, Math.min(scale, 5));

        viewOffsetX = mouseX - worldXBefore * scale;
        viewOffsetY = mouseY - worldYBefore * scale;
        
        draw();
    });

    function editText(el) {
        editingTextElement = el; selectedElements = [];
        const screenPos = worldToScreen(el.x, el.y);
        textEditor.style.display = 'block';
        textEditor.style.left = `${screenPos.x}px`;
        textEditor.style.top = `${screenPos.y}px`;
        const originalFontSize = parseInt((el.font || '16px').match(/(\d+)px/)[1] || 16);
        textEditor.style.font = el.font;
        textEditor.style.fontSize = `${originalFontSize * scale}px`;
        ctx.font = el.font || '16px sans-serif';
        textEditor.style.width = `${ctx.measureText(el.content).width * scale + 20}px`;
        textEditor.value = el.content;
        textEditor.focus();
        draw();
    }

    textEditor.addEventListener('blur', () => {
        if (editingTextElement) editingTextElement.content = textEditor.value;
        editingTextElement = null; textEditor.style.display = 'none'; draw();
    });
    textEditor.addEventListener('keydown', e => {
        e.stopPropagation();
        if (e.key === 'Enter') { e.preventDefault(); textEditor.blur(); } 
        else if (e.key === 'Escape') { textEditor.value = editingTextElement.content; textEditor.blur(); }
    });

    addFunctionBtn.addEventListener('click', (e) => {
        if (addFunctionBtn.disabled) return;
        updateActionButtonsState(); // Ensure modal buttons are correctly enabled/disabled
        const rect = addFunctionBtn.getBoundingClientRect(); functionModal.classList.remove('hidden');
        const modalRect = functionModal.getBoundingClientRect();
        functionModal.style.left = `${rect.left + (rect.width / 2) - (modalRect.width / 2)}px`;
        functionModal.style.top = `${rect.top - modalRect.height - 10}px`; 
        e.stopPropagation();
    });
    
    rotateBtn.addEventListener('click', () => {
        if (selectedElements.length === 0) return;
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        selectedElements.forEach(el => {
            if (el.type === 'line') { minX = Math.min(minX, el.x1, el.x2); minY = Math.min(minY, el.y1, el.y2); maxX = Math.max(maxX, el.x1, el.x2); maxY = Math.max(maxY, el.y1, el.y2); } 
            else if (el.type === 'rect') { minX = Math.min(minX, el.x); minY = Math.min(minY, el.y); maxX = Math.max(maxX, el.x + el.width); maxY = Math.max(maxY, el.y + el.height); } 
            else { minX = Math.min(minX, el.x); minY = Math.min(minY, el.y); maxX = Math.max(maxX, el.x); maxY = Math.max(maxY, el.y); }
        });

        const pivotX = (minX + maxX) / 2; const pivotY = (minY + maxY) / 2;
        const rotatePoint = (x, y, ox, oy) => ({ x: ox - (y - oy), y: oy + (x - ox) });

        selectedElements.forEach(el => {
            if (el.type === 'connector' || el.type === 'text') { const newPos = rotatePoint(el.x, el.y, pivotX, pivotY); el.x = snapToHalfGrid(newPos.x); el.y = snapToHalfGrid(newPos.y); } 
            else if (el.type === 'line') { const newP1 = rotatePoint(el.x1, el.y1, pivotX, pivotY); const newP2 = rotatePoint(el.x2, el.y2, pivotX, pivotY); el.x1 = snapToHalfGrid(newP1.x); el.y1 = snapToHalfGrid(newP1.y); el.x2 = snapToHalfGrid(newP2.x); el.y2 = snapToHalfGrid(newP2.y); } 
            else if (el.type === 'rect') { const newCenter = rotatePoint(el.x + el.width / 2, el.y + el.height / 2, pivotX, pivotY); const oldWidth = el.width; el.width = el.height; el.height = oldWidth; el.x = snapToHalfGrid(newCenter.x - el.width / 2); el.y = snapToHalfGrid(newCenter.y - el.height / 2); }
        });
        draw();
    });
    
    function addFunction(type) {
        const selectedConnectors = selectedElements.filter(el => el.type === 'connector');
        if (selectedConnectors.length < 2) return;

        const selectedIds = selectedConnectors.map(c => c.id).sort((a, b) => a - b);
        
        if (type === 'ç›¸é€š') {
             let groupsToMerge = [], remainingFunctions = [];
             const idSet = new Set(selectedIds);
             componentFunctions.forEach(func => {
                 if (func.type === 'ç›¸é€š' && func.connectors.some(id => idSet.has(id))) {
                     groupsToMerge.push(func);
                 } else {
                     remainingFunctions.push(func);
                 }
             });
             const mergedIds = new Set(selectedIds);
             groupsToMerge.forEach(group => group.connectors.forEach(id => mergedIds.add(id)));
             componentFunctions = [...remainingFunctions, { type: 'ç›¸é€š', connectors: Array.from(mergedIds).sort((a, b) => a - b) }];
        } else {
            if (selectedIds.length !== 2) return;
             // For relay functions, just add them. They can overlap.
            componentFunctions.push({ type, connectors: selectedIds });
        }

        functionModal.classList.add('hidden'); 
        selectedElements = []; 
        updateActionButtonsState(); 
        draw();
    }

    funcConductiveBtn.addEventListener('click', () => addFunction('ç›¸é€š'));
    funcCoilBtn.addEventListener('click', () => addFunction('coil'));
    funcAContactBtn.addEventListener('click', () => addFunction('a-contact'));
    funcBContactBtn.addEventListener('click', () => addFunction('b-contact'));


    window.addEventListener('click', (e) => {
        if (!functionModal.classList.contains('hidden') && e.target.id !== 'add-function-btn' && !functionModal.contains(e.target)) {
            functionModal.classList.add('hidden');
        }
    });

    window.addEventListener('keydown', e => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || editingTextElement) return;

        if (e.key === 'Escape') {
            if (['line', 'rect', 'text', 'connector', 'delete'].includes(activeTool)) {
                 setActiveTool('select');
            }
        }

        if (e.key === 'Delete' || e.key === 'Backspace') {
            if (selectedElements.length > 0) {
                const deletedIds = new Set(selectedElements.map(el => el.id));
                componentFunctions = componentFunctions.map(func => ({...func, connectors: func.connectors.filter(id => !deletedIds.has(id))})).filter(func => func.connectors.length > 1);
                drawingElements = drawingElements.filter(el => !selectedElements.includes(el));
                selectedElements = []; updateActionButtonsState(); draw();
            }
        }
    });

    exportBtn.addEventListener('click', () => {
        if (drawingElements.length === 0) { codeArea.value = "ç•«å¸ƒä¸Šæ²’æœ‰ä»»ä½•å…ƒä»¶å¯ä¾›è¼¸å‡ºã€‚"; return; }
        let minX = Infinity, minY = Infinity;
        drawingElements.forEach(el => { minX = Math.min(minX, el.x, el.x1 || el.x); minY = Math.min(minY, el.y, el.y1 || el.y); });

        const connectors = drawingElements.filter(el => el.type === 'connector');
        const connectorIdToLabel = new Map(); let tempConnectorCount = 1;
        connectors.forEach(c => connectorIdToLabel.set(c.id, c.label || `C${tempConnectorCount++}`));
        
        const dataBlock = `/* --- MAKER DATA ---\n${JSON.stringify({ drawingElements, componentFunctions }, null, 2)}\n--- END MAKER DATA --- */`;
        
        const connectLogic = (labels, prefix = 'c') => {
            if (labels.length < 2) return '';
            const gets = labels.map(l => `const ${prefix}_${l}=this.getConnectorByPole('${l}');`).join('');
            const allConnectors = `[${labels.map(l => `${prefix}_${l}`).join(',')}]`;
            const potentialChecks = labels.map(l => `${prefix}_${l}.potential`).join(',');
            return `{${gets} if(${allConnectors}.every(c=>c)){const maxPotential=Math.max(${potentialChecks});if(maxPotential>0){${allConnectors}.forEach(c=>c.potential=maxPotential);}}}`;
        };
        
        let logicCode = `updateLogic() {
    this.isEnergized = this.isEnergized ?? false;
    // --- Relay Logic: Determine if coil is energized ---
    let isEnergized = false;
    ${componentFunctions.filter(f => f.type === 'coil').map(func => {
        const labels = func.connectors.map(id => connectorIdToLabel.get(id)).filter(Boolean);
        if (labels.length !== 2) return '';
        const [l1, l2] = labels;
        return `const coil_c1 = this.getConnectorByPole('${l1}'); const coil_c2 = this.getConnectorByPole('${l2}'); if (coil_c1 && coil_c2 && coil_c1.potential !== coil_c2.potential) { isEnergized = true; }`;
    }).join('')}
    this.isEnergized = isEnergized;

    // --- A-Contact Logic (Normally Open) ---
    if (this.isEnergized) {
        ${componentFunctions.filter(f => f.type === 'a-contact').map(func => connectLogic(func.connectors.map(id => connectorIdToLabel.get(id)), 'ac')).join('')}
    }
    // --- B-Contact Logic (Normally Closed) ---
    if (!this.isEnergized) {
        ${componentFunctions.filter(f => f.type === 'b-contact').map(func => connectLogic(func.connectors.map(id => connectorIdToLabel.get(id)), 'bc')).join('')}
    }
    // --- Simple Conductive Logic ---
    ${componentFunctions.filter(f => f.type === 'ç›¸é€š').map(func => connectLogic(func.connectors.map(id => connectorIdToLabel.get(id)), 'cond')).join('')}
}`;

        let fullClassCode = `${dataBlock}\n\nclass CustomComponent extends Component { static instanceCount=0; constructor(x,y){super(x,y,'customComponent');this.instanceNumber=++CustomComponent.instanceCount;this.isEnergized=false;this._updateDimensions();this._rebuildConnectors();} _updateDimensions(){let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;const elements=${JSON.stringify(drawingElements)};if(elements.length===0){this.width=0;this.height=0;return}elements.forEach(el=>{minX=Math.min(minX,el.x,el.x1||el.x,el.x2||el.x);minY=Math.min(minY,el.y,el.y1||el.y,el.y2||el.y);maxX=Math.max(maxX,el.x+(el.width||0),el.x1||el.x,el.x2||el.x);maxY=Math.max(maxY,el.y+(el.height||0),el.y1||el.y,el.y2||el.y)});this.width=Math.ceil((maxX-minX)/${GRID_SIZE})*${GRID_SIZE};this.height=Math.ceil((maxY-minY)/${GRID_SIZE})*${GRID_SIZE};} getConnectorByPole(pole){return this.connectors.find(c=>c.pole===pole);} _rebuildConnectors() { this.connectors = []; ${connectors.map(c => `this.connectors.push({ id: \`\${this.id}-${connectorIdToLabel.get(c.id)}\`, parent: this, x: this.x + ${c.x - minX}, y: this.y + ${c.y - minY}, type: 'default', pole: '${connectorIdToLabel.get(c.id)}', potential: 0 });`).join('')}} draw(ctx) { const baseIsPowered = this.connectors.some(c => c.potential !== 0) || this.isEnergized; ctx.strokeStyle = baseIsPowered ? '#f6e05e' : '#a0aec0'; ctx.fillStyle = ctx.strokeStyle; ctx.lineWidth = 2; ${drawingElements.map(el => { if (el.type === 'connector') return ''; const relX = el.x - minX, relY = el.y - minY; switch(el.type) { case 'rect': return `ctx.strokeRect(this.x+${relX},this.y+${relY},${el.width},${el.height});`; case 'line': return `ctx.beginPath();ctx.moveTo(this.x+${el.x1 - minX},this.y+${el.y1 - minY});ctx.lineTo(this.x+${el.x2-minX},this.y+${el.y2-minY});ctx.stroke();`; case 'text': return `ctx.font='${el.font}';ctx.fillText(${el.content.includes('(X)') ? `\`${el.content.replaceAll('(X)', `\${this.instanceNumber}`)}\`` : `'${el.content.replace(/'/g, "\\'")}'`},this.x+${relX},this.y+${relY});`; default: return ''; } }).filter(Boolean).join('')} this.connectors.forEach(c => drawConnector(ctx, c)); } ${logicCode} toggle(){console.log('Toggled!')}}`;
        codeArea.value = fullClassCode;

        try { codeArea.focus(); codeArea.select(); const successful = document.execCommand('copy'); const originalText = exportBtn.innerHTML; if (successful) { exportBtn.innerHTML = 'âœ… å·²è¤‡è£½!'; } else { exportBtn.innerHTML = 'âŒ è¤‡è£½å¤±æ•—'; } setTimeout(() => { exportBtn.innerHTML = originalText; }, 2000); } catch (err) { console.error('è¤‡è£½æ™‚ç™¼ç”ŸéŒ¯èª¤:', err); const originalText = exportBtn.innerHTML; exportBtn.innerHTML = 'âŒ è¤‡è£½å¤±æ•—'; setTimeout(() => { exportBtn.innerHTML = originalText; }, 2000); }
        window.getSelection()?.removeAllRanges();
    });

    loadBtn.addEventListener('click', () => {
        const code = codeArea.value; const dataRegex = /\/\* --- MAKER DATA ---\s*(\{[\s\S]*?\})\s*--- END MAKER DATA --- \*\//; const match = code.match(dataRegex);
        const showFeedback = (btn, msg, isError) => { const originalText = btn.innerHTML, originalClass = btn.className; btn.innerHTML = msg; btn.className = isError ? originalClass.replace(/bg-teal-600/g, 'bg-red-600').replace(/hover:bg-teal-500/g, 'hover:bg-red-500') : originalClass.replace(/bg-teal-600/g, 'bg-green-600').replace(/hover:bg-teal-500/g, 'hover:bg-green-500'); setTimeout(() => { btn.innerHTML = originalText; btn.className = originalClass; }, 2500); };
        if (!match || !match[1]) { console.error('æ‰¾ä¸åˆ°æœ‰æ•ˆçš„å…ƒä»¶è³‡æ–™ã€‚'); showFeedback(loadBtn, 'âŒ è®€å–å¤±æ•—', true); return; }
        try { const data = JSON.parse(match[1]); if (!data.drawingElements || !data.componentFunctions) throw new Error('è³‡æ–™æ ¼å¼ä¸å®Œæ•´ã€‚'); drawingElements = data.drawingElements; componentFunctions = data.componentFunctions; elementIdCounter = drawingElements.reduce((maxId, el) => Math.max(maxId, el.id || 0), 0); selectedElements = []; editingTextElement = null; resizingElement = null; showFeedback(loadBtn, 'âœ… è®€å–æˆåŠŸ!', false); draw(); } catch (error) { console.error('è®€å–ç¨‹å¼ç¢¼å¤±æ•—:', error); showFeedback(loadBtn, 'âŒ æ ¼å¼éŒ¯èª¤', true); }
    });

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    updateActionButtonsState();
</script>
</body>
</html>

