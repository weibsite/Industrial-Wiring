<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é›»è·¯é…ç·šæ¨¡æ“¬å™¨</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', 'å¾®è»Ÿæ­£é»‘é«”', sans-serif;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .tool-item {
            @apply w-full p-3 bg-gray-700 text-white text-center rounded-lg cursor-grab shadow-md hover:bg-blue-500 transition-colors border-2 border-transparent;
            position: relative; /* Needed for pseudo-element positioning */
            z-index: 1;
        }
        /* Ensure text and icon are on top */
        .tool-item > * {
            position: relative;
            z-index: 10;
        }
        .tool-item.active {
             border-color: #ef4444; /* red-500 */
        }
        .tool-item.active::before {
            content: '';
            position: absolute;
            inset: 0;
            background-color: #ef4444; /* red-500 */
            opacity: 0.5;
            border-radius: 0.5rem; /* rounded-lg */
            z-index: 5;
        }

        canvas {
            background-color: #2d3748; /* bg-gray-800 */
            cursor: default;
        }
        .modal-bg {
            @apply fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-20;
        }
        .modal-content {
            @apply bg-gray-700 p-6 rounded-lg shadow-xl;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex h-screen overflow-hidden">

    <!-- Toolbar -->
    <div id="toolbar" class="w-48 bg-gray-800 p-4 flex flex-col space-y-4 shadow-lg z-10">
        <h2 class="text-xl font-bold text-center mb-4 border-b border-gray-600 pb-2">å·¥å…·åˆ—</h2>
        
        <div class="tool-item" draggable="true" data-type="nfb"><span>âš¡ ç„¡ç†”çµ²é–‹é—œ</span></div>
        <div id="bulb-tool-item" class="tool-item" draggable="true" data-type="bulb"><span>ğŸ’¡ ç‡ˆæ³¡</span></div>
        <div class="tool-item" draggable="true" data-type="switch"><span>ğŸ”˜ é–‹é—œå…ƒä»¶</span></div>
        <div class="tool-item" draggable="true" data-type="breaker"><span>ğŸ›¡ï¸ æ–·è·¯å™¨</span></div>
        <div class="tool-item" draggable="true" data-type="contactor"><span>ğŸ§² é›»ç£æ¥è§¸å™¨</span></div>
        <div class="tool-item" draggable="true" data-type="fuse"><span>ğŸ”¥ ä¿éšªçµ²åº§</span></div>

        <div class="pt-4 mt-4 border-t border-gray-600 space-y-4">
            <button id="move-tool" class="tool-item" data-type="move"><span>ğŸª› ç§»å‹•</span></button>
            
            <div>
                 <button id="wire-tool" class="tool-item" data-type="wire"><span>ã€°ï¸ é›»ç·š</span></button>
                 <div class="flex items-center justify-center space-x-2 mt-2">
                    <div id="wire-color-picker" class="w-6 h-6 rounded-md border-2 border-gray-400 cursor-pointer" title="åˆ‡æ›é è¨­é›»ç·šé¡è‰²"></div>
                    <button id="wire-thickness-picker" class="bg-gray-600 hover:bg-gray-500 px-3 py-1 rounded-md text-xs" title="åˆ‡æ›é è¨­é›»ç·šç²—ç´°">ç´°</button>
                 </div>
            </div>

            <button id="delete-tool" class="tool-item" data-type="delete"><span>ğŸ—‘ï¸ åˆªé™¤</span></button>
        </div>

        <div class="mt-auto text-center text-xs text-gray-400">
            <p>1. é»é¸æˆ–æ‹–æ›³å·¥å…·è‡³ç•«å¸ƒ</p>
            <p>2. ä¹…æŒ‰å…ƒä»¶å¯ç›´æ¥æ‹–æ›³</p>
            <p>3. å†æ¬¡é»æ“Šå·¥å…·å¯å–æ¶ˆ</p>
            <p class="mt-2">é»é¸å…ƒä»¶å¾ŒæŒ‰Delå¯åˆªé™¤</p>
            <p class="text-xs mt-2">é›™æ“Šå…ƒä»¶å¯é€²è¡Œç·¨è¼¯</p>
            <p class="text-xs mt-2">æ»¾è¼ªç¸®æ”¾/ä¸­éµå¹³ç§»</p>
        </div>
    </div>
    
    <!-- Canvas Container -->
    <div id="canvas-container" class="flex-1 bg-gray-700 p-2 overflow-hidden relative">
        <canvas id="canvas"></canvas>
        <!-- Save/Load Buttons -->
        <div class="absolute top-4 right-4 flex space-x-2">
            <button id="save-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded shadow-lg">
                ğŸ’¾ å­˜æª”
            </button>
            <button id="load-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded shadow-lg">
                ğŸ“‚ è®€å–
            </button>
            <input type="file" id="file-input" class="hidden" accept=".json">
        </div>
    </div>
    
    <!-- Modals -->
    <div id="pole-modal" class="modal-bg hidden">
        <div class="modal-content w-auto">
            <h3 id="pole-modal-title" class="text-lg font-bold mb-4">ç·¨è¼¯æ¥µæ•¸</h3>
            <p class="text-sm mb-4">é¸æ“‡å…ƒä»¶çš„æ¥µæ•¸ (Pæ•¸)</p>
            <div id="pole-options" class="grid grid-cols-2 gap-4">
                <!-- Options will be dynamically inserted here -->
            </div>
            <button id="close-pole-modal" class="w-full mt-6 bg-gray-500 hover:bg-gray-600 p-2 rounded">é—œé–‰</button>
        </div>
    </div>

    <div id="switch-modal" class="modal-bg hidden">
        <div class="modal-content w-96">
            <h3 class="text-lg font-bold mb-4">é¸æ“‡é–‹é—œé¡å‹</h3>
            <div class="grid grid-cols-2 gap-4">
                <button data-switch-type="pushbutton_no" class="switch-type-btn bg-green-600 hover:bg-green-700 p-3 rounded text-sm">æŒ‰éˆ• (å¸¸é–‹ NO)</button>
                <button data-switch-type="pushbutton_nc" class="switch-type-btn bg-orange-600 hover:bg-orange-700 p-3 rounded text-sm">æŒ‰éˆ• (å¸¸é–‰ NC)</button>
                <button data-switch-type="rotary_2pos" class="switch-type-btn bg-blue-600 hover:bg-blue-700 p-3 rounded text-sm">äºŒæ®µé¸æ“‡é–‹é—œ</button>
                <button data-switch-type="rotary_3pos" class="switch-type-btn bg-blue-600 hover:bg-blue-700 p-3 rounded text-sm">ä¸‰æ®µé¸æ“‡é–‹é—œ</button>
            </div>
            <button id="close-switch-modal" class="w-full mt-6 bg-gray-500 hover:bg-gray-600 p-2 rounded">é—œé–‰</button>
        </div>
    </div>

<script>
    // --- SETUP ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const toolbar = document.getElementById('toolbar');
    const canvasContainer = document.getElementById('canvas-container');
    const wireColorPicker = document.getElementById('wire-color-picker');
    const wireThicknessPicker = document.getElementById('wire-thickness-picker');

    const poleModal = document.getElementById('pole-modal');
    const poleModalTitle = document.getElementById('pole-modal-title');
    const poleOptionsContainer = document.getElementById('pole-options');
    const closePoleModalBtn = document.getElementById('close-pole-modal');

    const switchModal = document.getElementById('switch-modal');
    const closeSwitchModalBtn = document.getElementById('close-switch-modal');

    const saveButton = document.getElementById('save-button');
    const loadButton = document.getElementById('load-button');
    const fileInput = document.getElementById('file-input');

    const GRID_SIZE = 20;
    let components = [];
    let wires = [];
    let nextId = 0;
    
    // --- State Management ---
    let activeToolType = null;
    let draggedToolType = null;
    let draggedGhost = null;
    let placementPreview = null; // Also used for dragging previews
    let isDraggingPreview = false;
    let wiringState = { start: null, end: null };
    let wiringPathPoints = [];
    let selectedComponent = null; // NEW: For selection box and deletion
    let selectedComponentForEdit = null;
    let draggedComponent = null;
    let isPressingButton = false;
    let dragOffset = { x: 0, y: 0 };
    let longPressTimer = null;
    let isLongPressDrag = false;
    let potentialDragComponent = null;
    let longPressStartPos = { x: 0, y: 0 };
    let justDragged = false;
    
    // Viewport state for zoom and pan
    let view = { scale: 1.0, tx: 0, ty: 0 };
    let isPanning = false;
    let panStart = { x: 0, y: 0 };


    // --- Wire Settings ---
    let defaultWireColor = '#f6e05e';
    let defaultWireThickness = 3;
    const WIRE_DEFAULT_COLORS = ['#f6e05e', '#e53e3e', '#4299e1', '#48bb78', '#1a202c'];
    let wireColorIndex = 0;

    // Inline Wire editing
    let selectedWire = null;
    let wireEditorUI = { colorRect: null, thickRect: null, deleteRect: null };
    const WIRE_COLORS = {
        '#f6e05e': '#e53e3e', '#e53e3e': '#4299e1', '#4299e1': '#48bb78',
        '#48bb78': '#1a202c', '#1a202c': '#f6e05e',
    };
    const WIRE_THICKNESS = { 3: 6, 6: 3 };

    let nextBulbColorIndex = 0;
    const bulbColors = [
        { color: '#f6e05e', label: 'YL' }, { color: '#e53e3e', label: 'RL' }, { color: '#4299e1', label: 'BL' },
        { color: '#48bb78', label: 'GL' }, { color: '#ed8936', label: 'OL' },
    ];
    
    // --- UTILITY & HELPER FUNCTIONS ---
    const snapToGrid = (val) => Math.round(val / GRID_SIZE) * GRID_SIZE;
    const getCanvasMousePos = (e) => {
        const rect = canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        // Transform screen coordinates to world coordinates based on pan and zoom
        const worldX = (screenX - view.tx) / view.scale;
        const worldY = (screenY - view.ty) / view.scale;
        return { x: worldX, y: worldY };
    };
    const generateId = () => nextId++;

    function pDistance(x, y, x1, y1, x2, y2) {
        const A = x - x1; const B = y - y1; const C = x2 - x1; const D = y2 - y1;
        const dot = A * C + B * D; const len_sq = C * C + D * D;
        let param = -1; if (len_sq != 0) param = dot / len_sq;
        let xx, yy;
        if (param < 0) { xx = x1; yy = y1; } 
        else if (param > 1) { xx = x2; yy = y2; } 
        else { xx = x1 + param * C; yy = y1 + param * D; }
        return Math.sqrt(Math.pow(x - xx, 2) + Math.pow(y - yy, 2));
    }

    function checkCollision(rect1, ignoreId = -1) {
        for (const component of components) {
            if (component.id === ignoreId) continue;
            const rect2 = { x: component.x, y: component.y, width: component.width, height: component.height };
            if (rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y) {
                return true; // Collision detected
            }
        }
        return false; // No collision
    }

    function createTempComponent(type, x, y){
        switch (type) {
            case 'nfb': return new NFB(x, y);
            case 'bulb': return new Bulb(x, y, nextBulbColorIndex);
            case 'switch': return new Switch(x, y);
            case 'breaker': return new CircuitBreaker(x, y);
            case 'contactor': return new MagneticContactor(x, y);
            case 'fuse': return new FuseHolder(x, y);
            default: return null;
        }
    }

    // --- CANVAS RESIZING & DRAWING ---
    function resizeCanvas() {
        canvas.width = canvasContainer.clientWidth;
        canvas.height = canvasContainer.clientHeight;
        draw();
    }

    function drawGrid() {
        ctx.strokeStyle = '#4a5568';
        ctx.lineWidth = 0.5 / view.scale; // Keep line width visually constant

        // Get the visible area in world coordinates
        const left = -view.tx / view.scale;
        const top = -view.ty / view.scale;
        const right = (canvas.width - view.tx) / view.scale;
        const bottom = (canvas.height - view.ty) / view.scale;

        // Calculate the first grid line to draw
        const firstX = Math.floor(left / GRID_SIZE) * GRID_SIZE;
        const firstY = Math.floor(top / GRID_SIZE) * GRID_SIZE;

        for (let x = firstX; x <= right; x += GRID_SIZE) {
            ctx.beginPath();
            ctx.moveTo(x, top);
            ctx.lineTo(x, bottom);
            ctx.stroke();
        }
        for (let y = firstY; y <= bottom; y += GRID_SIZE) {
            ctx.beginPath();
            ctx.moveTo(left, y);
            ctx.lineTo(right, y);
            ctx.stroke();
        }
    }

    function drawWireEditor(ctx) {
        if (!selectedWire) {
            wireEditorUI = { colorRect: null, thickRect: null, deleteRect: null };
            return;
        }

        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        selectedWire.path.forEach(p => {
            minX = Math.min(minX, p.x); minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y);
        });
        const centerX = (minX + maxX) / 2; const centerY = (minY + maxY) / 2;
        
        const uiX = centerX + 15; const uiY = centerY - 10;
        const swatchSize = 20; const buttonWidth = 30; const buttonHeight = 20; const padding = 5;

        ctx.fillStyle = selectedWire.color;
        ctx.fillRect(uiX, uiY, swatchSize, swatchSize);
        ctx.strokeStyle = 'white'; ctx.lineWidth = 1 / view.scale;
        ctx.strokeRect(uiX, uiY, swatchSize, swatchSize);
        wireEditorUI.colorRect = { x: uiX, y: uiY, width: swatchSize, height: swatchSize };

        const thickButtonX = uiX + swatchSize + padding;
        ctx.fillStyle = '#4a5568';
        ctx.fillRect(thickButtonX, uiY, buttonWidth, buttonHeight);
        ctx.strokeStyle = 'white'; ctx.strokeRect(thickButtonX, uiY, buttonWidth, buttonHeight);
        ctx.fillStyle = 'white'; ctx.font = `${12 / view.scale}px sans-serif`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        const thickText = selectedWire.thickness === 3 ? 'ç´°' : 'ç²—';
        ctx.fillText(thickText, thickButtonX + buttonWidth / 2, uiY + buttonHeight / 2);
        wireEditorUI.thickRect = { x: thickButtonX, y: uiY, width: buttonWidth, height: buttonHeight };

        const deleteButtonX = thickButtonX + buttonWidth + padding;
        ctx.fillStyle = '#e53e3e';
        ctx.fillRect(deleteButtonX, uiY, buttonWidth, buttonHeight);
        ctx.strokeStyle = 'white'; ctx.strokeRect(deleteButtonX, uiY, buttonWidth, buttonHeight);
        ctx.fillStyle = 'white';
        ctx.fillText('åˆª', deleteButtonX + buttonWidth / 2, uiY + buttonHeight / 2);
        wireEditorUI.deleteRect = { x: deleteButtonX, y: uiY, width: buttonWidth, height: buttonHeight };
    }

    function getPreviewPath() {
        const path = [...wiringPathPoints];
        if (!wiringState.end) return path;
        const lastPoint = path[path.length - 1];
        const mousePoint = wiringState.end;
        
        const elbowPoint = { x: snapToGrid(mousePoint.x), y: lastPoint.y };
        const finalPoint = { x: snapToGrid(mousePoint.x), y: snapToGrid(mousePoint.y) };
        
        if(lastPoint.x !== elbowPoint.x) path.push(elbowPoint);
        if(elbowPoint.y !== finalPoint.y) path.push(finalPoint);

        return path;
    }

    function draw() {
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Apply view transformations (pan and zoom)
        ctx.translate(view.tx, view.ty);
        ctx.scale(view.scale, view.scale);

        // --- All world-space drawing happens here ---
        drawGrid();
        runSimulation();
        wires.forEach(w => w.draw(ctx));

        if(selectedWire){
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
            ctx.lineWidth = selectedWire.thickness + 5;
            ctx.lineCap = 'round';
            ctx.beginPath();
            if(selectedWire.path.length > 0) {
                 ctx.moveTo(selectedWire.path[0].x, selectedWire.path[0].y);
                 for (let i = 1; i < selectedWire.path.length; i++) { ctx.lineTo(selectedWire.path[i].x, selectedWire.path[i].y); }
            }
            ctx.stroke();
            ctx.lineCap = 'butt';
        }

        if (selectedComponent) {
            ctx.strokeStyle = '#a0aec0'; // gray-500
            ctx.lineWidth = 2 / view.scale;
            ctx.setLineDash([6 / view.scale, 3 / view.scale]);
            ctx.strokeRect(selectedComponent.x - 4, selectedComponent.y - 4, selectedComponent.width + 8, selectedComponent.height + 8);
            ctx.setLineDash([]);
        }

        components.forEach(c => c.draw(ctx));

        const previewComponent = placementPreview || draggedGhost;
        if (previewComponent) {
            ctx.save();
            ctx.globalAlpha = 0.7;
            const tempComp = createTempComponent(previewComponent.type, previewComponent.x, previewComponent.y);
            if (tempComp) {
                if (previewComponent.isColliding) {
                    ctx.strokeStyle = '#ef4444'; // Red for collision
                    ctx.lineWidth = 2 / view.scale;
                    ctx.strokeRect(tempComp.x, tempComp.y, tempComp.width, tempComp.height);
                }
                tempComp.draw(ctx);
            }
            ctx.restore();
        }
        
        if (draggedComponent) {
            ctx.strokeStyle = '#e53e3e';
            ctx.lineWidth = 2 / view.scale;
            ctx.setLineDash([6 / view.scale, 3 / view.scale]);
            ctx.strokeRect(draggedComponent.x - 2, draggedComponent.y - 2, draggedComponent.width + 4, draggedComponent.height + 4);
            ctx.setLineDash([]);
        }

        if (activeToolType === 'wire' && wiringState.start && wiringState.end) {
            const previewPath = getPreviewPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = defaultWireThickness;
            ctx.beginPath();
            if(previewPath.length > 0) {
                ctx.moveTo(previewPath[0].x, previewPath[0].y);
                for(let i=1; i < previewPath.length; i++) {
                    if (previewPath[i]) ctx.lineTo(previewPath[i].x, previewPath[i].y);
                }
            }
            ctx.stroke();
        }

        drawWireEditor(ctx);

        // Restore the context to its original state
        ctx.restore();
    }
    
    // --- COMPONENT CLASSES ---
    class Component {
        constructor(x, y, type) { this.id = generateId(); this.x = snapToGrid(x); this.y = snapToGrid(y); this.type = type; this.width = 0; this.height = 0; this.connectors = []; this.isPowered = false; }
        setPoles(poleType) { this.poleType = poleType; this._updateDimensions(); this._rebuildConnectors(); }
        updatePosition(newX, newY) {
            this.x = newX;
            this.y = newY;
            this._rebuildConnectors(); // This updates the connector positions
            wires.forEach(wire => {
                let segmentUpdated = false;
                if (wire.start.parent.id === this.id) {
                    const p0 = wire.path[0];
                    const p1 = wire.path[1];
                    p0.x = wire.start.x;
                    p0.y = wire.start.y;
                    if (p1) {
                        if (Math.abs(p0.x - p1.x) < Math.abs(p0.y - p1.y)) { // Vertical segment
                            p1.x = p0.x;
                        } else { // Horizontal segment
                            p1.y = p0.y;
                        }
                    }
                    segmentUpdated = true;
                }
                if (wire.end.parent.id === this.id) {
                    const pLast = wire.path[wire.path.length - 1];
                    const pSecondLast = wire.path[wire.path.length - 2];
                    pLast.x = wire.end.x;
                    pLast.y = wire.end.y;
                    if (pSecondLast) {
                        if (Math.abs(pLast.x - pSecondLast.x) < Math.abs(pLast.y - pSecondLast.y)) { // Vertical segment
                             pSecondLast.x = pLast.x;
                        } else { // Horizontal segment
                             pSecondLast.y = pLast.y;
                        }
                    }
                    segmentUpdated = true;
                }
            });
        }
        setSwitchType(type) { this.switchType = type; this.isPressed = false; this.position = 1; this._updateDimensions(); this._rebuildConnectors(); }
        draw(ctx) { throw new Error("Draw method must be implemented"); }
        isUnderMouse(mx, my) { return mx >= this.x && mx <= this.x + this.width && my >= this.y && my <= this.y + this.height; }
        getConnectorAt(mx, my) { for (const conn of this.connectors) { if (Math.hypot(conn.x - mx, conn.y - my) < GRID_SIZE / 2) return conn; } return null; }
        toggle() {}
        _rebuildConnectors() { throw new Error("RebuildConnectors must be implemented for " + this.type); }
    }

    class NFB extends Component {
        constructor(x, y) { super(x, y, 'nfb'); this.poleType = '2P'; this.isOn = true; this._updateDimensions(); this._rebuildConnectors(); }
        _updateDimensions() { 
            let poleCount = 0;
            if (this.poleType === '1P') poleCount = 1; if (this.poleType === '2P') poleCount = 2;
            if (this.poleType === '3P') poleCount = 3; if (this.poleType === '4P') poleCount = 4;
            this.width = GRID_SIZE * (poleCount + 1); this.height = GRID_SIZE * 5; 
        }
        _rebuildConnectors() {
            this.connectors = [];
            const labels = [];
            if (this.poleType === '1P') labels.push('L'); if (this.poleType === '2P') labels.push('L', 'N');
            if (this.poleType === '3P') labels.push('R', 'S', 'T'); if (this.poleType === '4P') labels.push('R', 'S', 'T', 'N');
            
            labels.forEach((label, i) => {
                 const xPos = this.x + GRID_SIZE * (i + 1);
                 const isNeutral = label === 'N' || label === 'T';
                 this.connectors.push({ id: `${this.id}-in-${i}`, parent: this, x: xPos, y: this.y, type: isNeutral ? 'neutral' : 'positive', pole: label, potential: 0 });
                 this.connectors.push({ id: `${this.id}-out-${i}`, parent: this, x: xPos, y: this.y + this.height, type: 'output', pole: label, potential: 0 });
            });
        }
        toggle() { this.isOn = !this.isOn; }
        draw(ctx) {
            const baseIsPowered = this.connectors.some(c => c.potential !== 0);
            ctx.strokeStyle = baseIsPowered ? '#f6e05e' : '#a0aec0';
            ctx.lineWidth = 2; ctx.strokeRect(this.x, this.y, this.width, this.height);
            ctx.fillStyle = ctx.strokeStyle; ctx.font = `${GRID_SIZE*0.7}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText('NFB', this.x + this.width / 2, this.y + GRID_SIZE * 0.7);
            ctx.fillText(this.poleType, this.x + this.width / 2, this.y + GRID_SIZE * 1.7);
            
            this.connectors.filter(c => c.type !== 'output').forEach(c => {
                 ctx.fillStyle = '#a0aec0';
                 ctx.fillText(c.pole, c.x, this.y + GRID_SIZE * 2.8);
                 const startY = this.y + GRID_SIZE * 3.5; const endY = this.y + this.height - GRID_SIZE;
                 const isBluePole = c.pole === 'N' || (this.poleType === '3P' && c.pole === 'T');
                 const outputConn = this.connectors.find(conn => conn.pole === c.pole && conn.type === 'output');
                 ctx.strokeStyle = outputConn && outputConn.potential !== 0 ? (isBluePole ? '#4299e1' : '#f6e05e') : '#a0aec0';
                 ctx.beginPath(); ctx.moveTo(c.x, startY);
                 if (this.isOn) { ctx.lineTo(c.x, endY); } 
                 else { ctx.lineTo(c.x + GRID_SIZE * 0.4, endY - GRID_SIZE * 0.4); }
                 ctx.stroke();
            });

            this.connectors.forEach(c => {
                ctx.fillStyle = c.potential !== 0 ? (c.potential === 1 ? '#f6e05e' : '#4299e1') : 'white';
                ctx.beginPath(); ctx.arc(c.x, c.y, 4, 0, Math.PI * 2); ctx.fill();
            });
        }
    }

    class Bulb extends Component {
        constructor(x, y, colorIndex = 0) { 
            super(x, y, 'bulb'); 
            this.width = GRID_SIZE * 2; 
            this.height = GRID_SIZE * 2; 
            this.colorIndex = colorIndex; 
            this._updateColor(); 
            this._rebuildConnectors(); 
        }
        _rebuildConnectors() {
             this.connectors = [
                { id: `${this.id}-0`, parent: this, x: this.x + this.width / 2, y: this.y, potential: 0 },
                { id: `${this.id}-1`, parent: this, x: this.x + this.width / 2, y: this.y + this.height, potential: 0 }
            ];
        }
        _updateColor() { const c = bulbColors[this.colorIndex]; this.color = c.color; this.label = c.label; }
        cycleColor() { this.colorIndex = (this.colorIndex + 1) % bulbColors.length; this._updateColor(); }
        draw(ctx) {
            this.isPowered = (this.connectors[0].potential === 1 && this.connectors[1].potential === -1) || (this.connectors[0].potential === -1 && this.connectors[1].potential === 1);
            ctx.strokeStyle = this.isPowered ? this.color : '#a0aec0'; ctx.lineWidth = 2;
            
            ctx.beginPath(); 
            ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
            
            ctx.shadowBlur = 0;
            if (this.isPowered) {
                ctx.fillStyle = this.color; 
                ctx.fill();
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
            }
            ctx.stroke();

            ctx.fillStyle = this.isPowered ? 'black' : this.color; 
            ctx.font = `${GRID_SIZE*0.9}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(this.label, this.x + this.width / 2, this.y + this.height / 2);
            ctx.shadowBlur = 0;

            this.connectors.forEach(c => {
                ctx.fillStyle = c.potential !== 0 ? (c.potential === 1 ? '#f6e05e' : '#4299e1') : 'white';
                ctx.beginPath(); ctx.arc(c.x, c.y, 4, 0, Math.PI * 2); ctx.fill();
            });
        }
    }

    class Switch extends Component {
        constructor(x, y) { super(x, y, 'switch'); this.switchType = 'pushbutton_no'; this.isPressed = false; this.position = 1; this._updateDimensions(); this._rebuildConnectors(); }
        _updateDimensions() { 
            if (this.switchType.startsWith('pushbutton')) {
                this.width = GRID_SIZE * 2;
                this.height = GRID_SIZE * 4;
            } else if (this.switchType === 'rotary_2pos') {
                this.width = GRID_SIZE * 5;
                this.height = GRID_SIZE * 5;
            } else if (this.switchType === 'rotary_3pos') { 
                this.width = GRID_SIZE * 5;
                this.height = GRID_SIZE * 5;
            } 
        }
        _rebuildConnectors() {
            this.connectors = []; const cX = this.x + this.width / 2;
            if (this.switchType.startsWith('pushbutton')) {
                this.connectors.push({ id: `${this.id}-in`, parent: this, x: cX, y: this.y, type: 'in', potential: 0 });
                this.connectors.push({ id: `${this.id}-out`, parent: this, x: cX, y: this.y + this.height, type: 'out', potential: 0 });
            } else if (this.switchType === 'rotary_2pos') {
                this.connectors.push({ id: `${this.id}-com`, parent: this, x: cX, y: this.y, type: 'com', potential: 0 });
                this.connectors.push({ id: `${this.id}-out_left`, parent: this, x: this.x + GRID_SIZE, y: this.y + this.height, type: 'out_left', potential: 0 });
                this.connectors.push({ id: `${this.id}-out_right`, parent: this, x: this.x + this.width - GRID_SIZE, y: this.y + this.height, type: 'out_right', potential: 0 });
            } else if (this.switchType === 'rotary_3pos') {
                 this.connectors.push({ id: `${this.id}-com`, parent: this, x: cX, y: this.y, type: 'com', potential: 0 });
                this.connectors.push({ id: `${this.id}-out_left`, parent: this, x: this.x + GRID_SIZE, y: this.y + this.height, type: 'out_left', potential: 0 });
                this.connectors.push({ id: `${this.id}-out_middle`, parent: this, x: cX, y: this.y + this.height, type: 'out_middle', potential: 0 });
                this.connectors.push({ id: `${this.id}-out_right`, parent: this, x: this.x + this.width - GRID_SIZE, y: this.y + this.height, type: 'out_right', potential: 0 });
            }
        }
        toggle() { 
            if (this.switchType === 'rotary_2pos') { this.position = (this.position === 1) ? 2 : 1; } 
            else if (this.switchType === 'rotary_3pos') { this.position = (this.position % 3) + 1; }
        }
        press() { if (this.switchType.startsWith('pushbutton')) this.isPressed = true; }
        release() { if (this.switchType.startsWith('pushbutton')) this.isPressed = false; }
        draw(ctx) {
            const baseIsPowered = this.connectors.some(c => c.potential !== 0);
            ctx.strokeStyle = baseIsPowered ? '#f6e05e' : '#a0aec0'; 
            ctx.lineWidth = 2;
            
            if (this.switchType.startsWith('rotary')) {
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                ctx.stroke();
            } else {
                ctx.strokeRect(this.x, this.y, this.width, this.height);
            }

            ctx.font = `${GRID_SIZE*0.7}px sans-serif`; 
            ctx.textAlign = 'center'; 
            ctx.textBaseline = 'middle';

            if (this.switchType.startsWith('pushbutton')) this._drawPushButton(ctx); 
            else this._drawRotarySwitch(ctx);

            this.connectors.forEach(c => {
                ctx.fillStyle = c.potential !== 0 ? (c.potential === 1 ? '#f6e05e' : '#4299e1') : 'white';
                ctx.beginPath(); ctx.arc(c.x, c.y, 4, 0, Math.PI * 2); ctx.fill();
            });
        }
        _drawPushButton(ctx) {
            ctx.fillText('æŒ‰éˆ•', this.x + this.width/2, this.y + GRID_SIZE * 0.7);
            const typeLabel = this.switchType.endsWith('no') ? 'NO' : 'NC';
            ctx.fillText(typeLabel, this.x + this.width / 2, this.y + this.height - GRID_SIZE * 0.5);

            const cX = this.x + this.width / 2;
            const midY = this.y + this.height / 2;
            
            ctx.beginPath(); ctx.moveTo(cX, this.y + 5); ctx.lineTo(cX, midY - 5); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cX, this.y + this.height - 5); ctx.lineTo(cX, midY + 5); ctx.stroke();

            ctx.beginPath();
            const isNo = this.switchType.endsWith('no');
            const isClosed = (isNo && this.isPressed) || (!isNo && !this.isPressed);

            if (isClosed) { ctx.moveTo(cX, midY - 5); ctx.lineTo(cX, midY + 5); } 
            else { ctx.moveTo(cX, midY - 5); ctx.lineTo(cX + 8, midY - 2); }
            ctx.stroke();
        }
        _drawRotarySwitch(ctx) {
            ctx.fillStyle = this.connectors.some(c => c.potential !== 0) ? '#f6e05e' : '#a0aec0';
            ctx.fillText('æ—‹è½‰', this.x + this.width/2, this.y + GRID_SIZE * 0.7);

            const cX = this.x + this.width / 2;
            const cY = this.y + this.height / 2;
            const radius = (this.width / 2) * 0.7; // Radius for the indicator line

            ctx.beginPath();
            ctx.arc(cX, cY, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#666';
            ctx.fill();

            let angle = 0;
            if (this.switchType === 'rotary_2pos') {
                angle = (this.position === 1) ? Math.PI * 0.8 : Math.PI * 0.2;
            } else if (this.switchType === 'rotary_3pos') {
                if (this.position === 1) angle = Math.PI * 0.8; 
                else if (this.position === 2) angle = Math.PI * 0.5;
                else if (this.position === 3) angle = Math.PI * 0.2;
            }

            ctx.beginPath();
            ctx.moveTo(cX, cY);
            ctx.lineTo(cX + radius * Math.cos(angle), cY + radius * Math.sin(angle));
            ctx.strokeStyle = this.connectors.some(c => c.potential !== 0) ? '#f6e05e' : '#a0aec0';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.lineWidth = 2; 
        }
    }
    
    class CircuitBreaker extends Component {
        constructor(x, y) { super(x, y, 'breaker'); this.poleType = '1P'; this.state = 'ON'; this._updateDimensions(); this._rebuildConnectors(); }
        _updateDimensions() { const poles = parseInt(this.poleType[0]); this.width = GRID_SIZE * (poles + 1); this.height = GRID_SIZE * 4; }
        _rebuildConnectors() {
            this.connectors = []; const poles = parseInt(this.poleType[0]);
            for (let i = 0; i < poles; i++) {
                const xPos = this.x + GRID_SIZE * (i + 1);
                this.connectors.push({ id: `${this.id}-in-${i}`, parent: this, x: xPos, y: this.y, type: 'input', pole: i, potential: 0 });
                this.connectors.push({ id: `${this.id}-out-${i}`, parent: this, x: xPos, y: this.y + this.height, type: 'output', pole: i, potential: 0 });
            }
        }
        toggle(isTrip=false) { if (isTrip) this.state = 'TRIPPED'; else this.state = (this.state === 'TRIPPED') ? 'OFF' : (this.state === 'ON' ? 'OFF' : 'ON'); }
        draw(ctx) {
            const baseIsPowered = this.connectors.some(c => c.potential !== 0);
            ctx.strokeStyle = baseIsPowered ? '#f6e05e' : '#a0aec0'; ctx.lineWidth = 2; ctx.strokeRect(this.x, this.y, this.width, this.height);
            ctx.fillStyle = ctx.strokeStyle; ctx.font = `${GRID_SIZE*0.7}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText('CB', this.x + this.width / 2, this.y + GRID_SIZE * 0.7);
            const poles = parseInt(this.poleType[0]);
            for (let i = 0; i < poles; i++) { /* Drawing logic omitted for brevity */ }
            this.connectors.forEach(c => {
                ctx.fillStyle = c.potential !== 0 ? (c.potential === 1 ? '#f6e05e' : '#4299e1') : 'white';
                ctx.beginPath(); ctx.arc(c.x, c.y, 4, 0, Math.PI * 2); ctx.fill();
            });
        }
    }

    class MagneticContactor extends Component {
        constructor(x, y) {
            super(x, y, 'contactor');
            this.coilEnergized = false;
            this._updateDimensions();
            this._rebuildConnectors();
        }
        _updateDimensions() {
            this.width = GRID_SIZE * 8;
            this.height = GRID_SIZE * 6;
        }
        _rebuildConnectors() {
            this.connectors = [];
            const coilY = this.y;
            const mainInY = this.y + GRID_SIZE * 2;
            const mainOutY = this.y + GRID_SIZE * 5;

            this.connectors.push({ id: `${this.id}-A1`, parent: this, x: this.x + GRID_SIZE * 2, y: coilY, type: 'coil', potential: 0 });
            this.connectors.push({ id: `${this.id}-A2`, parent: this, x: this.x + this.width - GRID_SIZE * 3 , y: coilY, type: 'coil', potential: 0 });
            
            this.connectors.push({ id: `${this.id}-L1`, parent: this, x: this.x + GRID_SIZE, y: mainInY, type: 'main-in', pole: 0, potential: 0 });
            this.connectors.push({ id: `${this.id}-L2`, parent: this, x: this.x + GRID_SIZE * 3, y: mainInY, type: 'main-in', pole: 1, potential: 0 });
            this.connectors.push({ id: `${this.id}-L3`, parent: this, x: this.x + GRID_SIZE * 5, y: mainInY, type: 'main-in', pole: 2, potential: 0 });
            
            this.connectors.push({ id: `${this.id}-T1`, parent: this, x: this.x + GRID_SIZE, y: mainOutY, type: 'main-out', pole: 0, potential: 0 });
            this.connectors.push({ id: `${this.id}-T2`, parent: this, x: this.x + GRID_SIZE * 3, y: mainOutY, type: 'main-out', pole: 1, potential: 0 });
            this.connectors.push({ id: `${this.id}-T3`, parent: this, x: this.x + GRID_SIZE * 5, y: mainOutY, type: 'main-out', pole: 2, potential: 0 });

            this.connectors.push({ id: `${this.id}-aux-no-in`, parent: this, x: this.x + this.width - GRID_SIZE, y: mainInY, type: 'aux-no-in', potential: 0 });
            this.connectors.push({ id: `${this.id}-aux-no-out`, parent: this, x: this.x + this.width - GRID_SIZE, y: mainOutY, type: 'aux-no-out', potential: 0 });
            
            this.connectors.push({ id: `${this.id}-aux-nc-in`, parent: this, x: this.x, y: mainOutY - GRID_SIZE, type: 'aux-nc-in', potential: 0 });
            this.connectors.push({ id: `${this.id}-aux-nc-out`, parent: this, x: this.x, y: mainInY + GRID_SIZE, type: 'aux-nc-out', potential: 0 });
        }
        draw(ctx) {
            this.coilEnergized = (this.connectors.find(c=>c.id===`${this.id}-A1`).potential === 1 && this.connectors.find(c=>c.id===`${this.id}-A2`).potential === -1) || (this.connectors.find(c=>c.id===`${this.id}-A1`).potential === -1 && this.connectors.find(c=>c.id===`${this.id}-A2`).potential === 1);
            const baseIsPowered = this.connectors.some(c => c.potential !== 0);
            ctx.strokeStyle = baseIsPowered ? '#f6e05e' : '#a0aec0';
            ctx.lineWidth = 2;
            
            const mainBoxY = this.y + GRID_SIZE;
            const mainBoxHeight = GRID_SIZE * 5;
            ctx.strokeRect(this.x, mainBoxY, this.width, mainBoxHeight);

            ctx.fillStyle = baseIsPowered ? '#f6e05e' : '#a0aec0';
            ctx.font = `${GRID_SIZE*0.6}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            ctx.fillText('A1', this.x + GRID_SIZE * 2, this.y - GRID_SIZE * 0.5);
            ctx.fillText('A2', this.x + this.width - GRID_SIZE * 3, this.y - GRID_SIZE * 0.5);
            ctx.strokeRect(this.x + GRID_SIZE * 2, this.y, this.width - GRID_SIZE * 5, GRID_SIZE);

            const mainLabels = ['L1','L2','L3','NO'];
            const auxLabels = ['T1','T2','T3','NO'];
            
            for (let i = 0; i < 4; i++) {
                const xPos = this.x + GRID_SIZE + (i * GRID_SIZE * 2);
                const startY = mainBoxY + GRID_SIZE;
                const endY = mainBoxY + mainBoxHeight - GRID_SIZE;

                ctx.fillText(mainLabels[i], xPos, startY - GRID_SIZE * 0.5);
                ctx.fillText(auxLabels[i], xPos, endY + GRID_SIZE * 0.5);
                
                ctx.beginPath(); ctx.arc(xPos, startY, 3, 0, Math.PI * 2); ctx.moveTo(xPos, startY + 3); ctx.lineTo(xPos, startY + GRID_SIZE * 0.5); ctx.stroke();
                ctx.beginPath(); ctx.arc(xPos, endY, 3, 0, Math.PI * 2); ctx.moveTo(xPos, endY - 3); ctx.lineTo(xPos, endY - GRID_SIZE * 0.5); ctx.stroke();
                
                ctx.beginPath();
                const isAuxNO = i === 3;
                if ((!isAuxNO && this.coilEnergized) || (isAuxNO && this.coilEnergized)) {
                    ctx.moveTo(xPos, startY + GRID_SIZE * 0.5); ctx.lineTo(xPos, endY - GRID_SIZE * 0.5);
                } else {
                    ctx.moveTo(xPos, startY + GRID_SIZE * 0.5); ctx.lineTo(xPos + 8, startY + GRID_SIZE * 0.5 - 3);
                }
                ctx.stroke();
            }

            const ncIn = this.connectors.find(c => c.type === 'aux-nc-in');
            const ncOut = this.connectors.find(c => c.type === 'aux-nc-out');
            ctx.fillText('NC', ncIn.x - GRID_SIZE * 0.5, (ncIn.y + ncOut.y) / 2);
            ctx.beginPath();
            ctx.arc(ncIn.x, ncIn.y, 3, 0, Math.PI * 2);
            ctx.moveTo(ncIn.x+3, ncIn.y); ctx.lineTo(ncIn.x + GRID_SIZE, ncIn.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(ncOut.x, ncOut.y, 3, 0, Math.PI * 2);
            ctx.moveTo(ncOut.x+3, ncOut.y); ctx.lineTo(ncOut.x + GRID_SIZE, ncOut.y);
            ctx.stroke();
            ctx.beginPath();
            if(this.coilEnergized) {
                ctx.moveTo(ncIn.x + GRID_SIZE, ncIn.y); ctx.lineTo(ncIn.x + GRID_SIZE + 8, ncIn.y - 3);
            } else {
                ctx.moveTo(ncIn.x + GRID_SIZE, ncIn.y); ctx.lineTo(ncOut.x + GRID_SIZE, ncOut.y);
                ctx.moveTo(ncIn.x + GRID_SIZE, ncOut.y); ctx.lineTo(ncOut.x + GRID_SIZE, ncIn.y);
            }
            ctx.stroke();

            ctx.setLineDash([2, 3]);
            ctx.beginPath();
            const linkCoilY = this.y + GRID_SIZE; 
            const linkSwitchY = this.y + GRID_SIZE * 2.5;
            ctx.moveTo(this.x + this.width/2 - GRID_SIZE, linkCoilY); 
            ctx.lineTo(this.x + this.width/2 - GRID_SIZE, linkSwitchY - 5);
            ctx.stroke();
            ctx.setLineDash([]);
            
            this.connectors.forEach(c => {
                ctx.fillStyle = c.potential !== 0 ? (c.potential === 1 ? '#f6e05e' : '#4299e1') : 'white';
                ctx.beginPath(); ctx.arc(c.x, c.y, 4, 0, Math.PI * 2); ctx.fill();
            });
        }
    }

    class FuseHolder extends Component {
        constructor(x, y) { 
            super(x, y, 'fuse'); 
            this.width = GRID_SIZE * 2; 
            this.height = GRID_SIZE * 4; 
            this.isBlown = false;
            this._rebuildConnectors();
        }
        _rebuildConnectors() {
            this.connectors = [
                { id: `${this.id}-in`, parent: this, x: this.x + this.width / 2, y: this.y, potential: 0 },
                { id: `${this.id}-out`, parent: this, x: this.x + this.width / 2, y: this.y + this.height, potential: 0 }
            ];
        }
        toggle() { 
            this.isBlown = !this.isBlown; 
        }
        draw(ctx) {
            const baseIsPowered = this.connectors.some(c => c.potential !== 0);
            ctx.strokeStyle = baseIsPowered ? '#f6e05e' : '#a0aec0'; 
            ctx.lineWidth = 2; 
            
            const cX = this.x + this.width / 2;
            ctx.strokeRect(this.x, this.y + GRID_SIZE, this.width, this.height - 2 * GRID_SIZE);
            ctx.beginPath();
            ctx.moveTo(cX, this.y); ctx.lineTo(cX, this.y + GRID_SIZE);
            ctx.moveTo(cX, this.y + this.height - GRID_SIZE); ctx.lineTo(cX, this.y + this.height);
            ctx.stroke();

            if (this.isBlown) {
                ctx.strokeStyle = '#e53e3e'; ctx.lineWidth = 3; 
                const midY = this.y + this.height / 2;
                ctx.beginPath(); 
                ctx.moveTo(cX - 5, midY - 8); ctx.lineTo(cX + 5, midY); 
                ctx.lineTo(cX - 5, midY); ctx.lineTo(cX + 5, midY + 8); 
                ctx.stroke();
            } else { 
                ctx.beginPath(); 
                ctx.moveTo(this.x + this.width / 2, this.y + GRID_SIZE + 4); 
                ctx.lineTo(this.x + this.width / 2, this.y + this.height - GRID_SIZE - 4); 
                ctx.stroke(); 
            }
            this.connectors.forEach(c => {
                ctx.fillStyle = c.potential !== 0 ? (c.potential === 1 ? '#f6e05e' : '#4299e1') : 'white';
                ctx.beginPath(); ctx.arc(c.x, c.y, 4, 0, Math.PI * 2); ctx.fill();
            });
        }
    }

    class Wire {
        constructor(startConnector, endConnector, path) { 
            this.id = generateId(); 
            this.start = startConnector; 
            this.end = endConnector; 
            this.potential = 0; 
            this.color = defaultWireColor; 
            this.thickness = defaultWireThickness; 
            this.path = path; 
        }
        calculatePath() {
            if (!this.start || !this.end || !this.path || this.path.length === 0) return;
            this.path[0].x = this.start.x;
            this.path[0].y = this.start.y;
            this.path[this.path.length - 1].x = this.end.x;
            this.path[this.path.length - 1].y = this.end.y;
        }
        draw(ctx) {
            if (!this.path || this.path.length < 2) return;
            if (this.potential === 1) ctx.strokeStyle = '#f6e05e'; else if (this.potential === -1) ctx.strokeStyle = '#4299e1'; else ctx.strokeStyle = this.color;
            ctx.lineWidth = this.thickness; ctx.beginPath(); ctx.moveTo(this.path[0].x, this.path[0].y);
            for (let i = 1; i < this.path.length; i++) { ctx.lineTo(this.path[i].x, this.path[i].y); }
            ctx.stroke();
        }
    }
    
    // --- SIMULATION LOGIC ---
    function runSimulation() {
        components.forEach(c => c.connectors.forEach(conn => conn.potential = 0));
        wires.forEach(w => w.potential = 0);

        const powerSources = components.filter(c => c.type === 'nfb');
        if (powerSources.length === 0) return;

        [1, -1].forEach(potential => {
            let queue = [];
            powerSources.forEach(nfb => {
                const startConnectors = nfb.connectors.filter(c => (potential === 1 && c.type === 'positive') || (potential === -1 && c.type === 'neutral') );
                startConnectors.forEach(c => { c.potential = potential; queue.push(c); });
            });

            let visitedConnectors = new Set(queue.map(c => c.id));

            while (queue.length > 0) {
                const currentConn = queue.shift();
                
                wires.forEach(w => {
                    let otherConn = null;
                    if (w.start.id === currentConn.id) otherConn = w.end;
                    if (w.end.id === currentConn.id) otherConn = w.start;
                    
                    if (otherConn && !visitedConnectors.has(otherConn.id)) {
                        w.potential = potential; otherConn.potential = potential;
                        visitedConnectors.add(otherConn.id); queue.push(otherConn);
                    }
                });
                
                const comp = currentConn.parent;
                let internalConnections = [];
                if (comp.type === 'fuse' && !comp.isBlown) internalConnections.push([comp.connectors[0], comp.connectors[1]]);
                if (comp.type === 'breaker' && comp.state === 'ON') { /* ... */ }
                if (comp.type === 'switch') {
                    if (comp.switchType.startsWith('pushbutton')) {
                        const isNo = comp.switchType.endsWith('no');
                        const isClosed = (isNo && comp.isPressed) || (!isNo && !comp.isPressed);
                        if (isClosed) internalConnections.push([comp.connectors[0], comp.connectors[1]]);
                    } else if (comp.switchType === 'rotary_2pos') {
                        if (comp.position === 1) internalConnections.push([comp.connectors.find(c=>c.type==='com'), comp.connectors.find(c=>c.type==='out_left')]);
                        else internalConnections.push([comp.connectors.find(c=>c.type==='com'), comp.connectors.find(c=>c.type==='out_right')]);
                    } else if (comp.switchType === 'rotary_3pos') {
                        if (comp.position === 1) internalConnections.push([comp.connectors.find(c=>c.type==='com'), comp.connectors.find(c=>c.type==='out_left')]);
                        if (comp.position === 2) internalConnections.push([comp.connectors.find(c=>c.type==='com'), comp.connectors.find(c=>c.type==='out_middle')]);
                        if (comp.position === 3) internalConnections.push([comp.connectors.find(c=>c.type==='com'), comp.connectors.find(c=>c.type==='out_right')]);
                    }
                }
                if (comp.type === 'contactor') {
                    const isCoilEnergized = comp.coilEnergized;
                    if (isCoilEnergized) {
                        for(let p=0; p<3; p++) {
                             internalConnections.push([comp.connectors.find(c=>c.type==='main-in'&&c.pole===p), comp.connectors.find(c=>c.type==='main-out'&&c.pole===p)]);
                        }
                        internalConnections.push([comp.connectors.find(c=>c.type==='aux-no-in'), comp.connectors.find(c=>c.type==='aux-no-out')]);
                    } else {
                        internalConnections.push([comp.connectors.find(c=>c.type==='aux-nc-in'), comp.connectors.find(c=>c.type==='aux-nc-out')]);
                    }
                }
                
                if (comp.type === 'nfb' && comp.isOn) {
                     comp.connectors.filter(c => c.type === 'positive' || c.type === 'neutral').forEach(startConn => {
                         const endConn = comp.connectors.find(c => c.type === 'output' && c.pole === startConn.pole);
                         internalConnections.push([startConn, endConn]);
                     });
                }

                internalConnections.forEach(([connA, connB]) => {
                    if(!connA || !connB) return;
                    let otherConn = null;
                    if(connA.id === currentConn.id) otherConn = connB;
                    if(connB.id === currentConn.id) otherConn = connA;
                    if(otherConn && !visitedConnectors.has(otherConn.id)) {
                        otherConn.potential = potential; visitedConnectors.add(otherConn.id); queue.push(otherConn);
                    }
                });
            }
        });

        components.filter(c => c.type === 'fuse' && !c.isBlown).forEach(fuse => {
            const potA = fuse.connectors[0].potential;
            const potB = fuse.connectors[1].potential;
            if ((potA === 1 && potB === -1) || (potA === -1 && potB === 1)) {
                fuse.isBlown = true;
            }
        });
    }

    // --- EVENT HANDLERS ---
    function handleToolClick(toolElement) {
        placementPreview = null;
        wiringState = { start: null, end: null };
        wiringPathPoints = [];
        selectedComponent = null;
        const clickedToolType = toolElement.dataset.type;

        if (toolElement.classList.contains('active')) {
            toolElement.classList.remove('active');
            activeToolType = null;
            canvas.style.cursor = 'default';
        } else {
            document.querySelectorAll('#toolbar .tool-item.active').forEach(el => el.classList.remove('active'));
            toolElement.classList.add('active');
            activeToolType = clickedToolType;

            canvas.style.cursor = 'default';
            if (activeToolType === 'move') canvas.style.cursor = 'grab';
            if (activeToolType === 'wire') canvas.style.cursor = 'crosshair';
            if (activeToolType === 'delete') canvas.style.cursor = 'not-allowed';
        }
        draw();
    }

    canvas.addEventListener('mousemove', (e) => {
        if (isPanning) {
            canvas.style.cursor = 'grabbing';
            const dx = e.clientX - panStart.x;
            const dy = e.clientY - panStart.y;
            view.tx += dx;
            view.ty += dy;
            panStart = { x: e.clientX, y: e.clientY };
            draw();
            return;
        }

        const pos = getCanvasMousePos(e);

        if (longPressTimer) {
            const dist = Math.hypot(pos.x - longPressStartPos.x, pos.y - longPressStartPos.y);
            if (dist > 5) { clearTimeout(longPressTimer); longPressTimer = null; }
        }

        if (isDraggingPreview && placementPreview) {
            placementPreview.x = snapToGrid(pos.x - dragOffset.x);
            placementPreview.y = snapToGrid(pos.y - dragOffset.y);
            justDragged = true;
        } else if ((activeToolType === 'move' || isLongPressDrag) && draggedComponent) { 
            const newX = snapToGrid(pos.x - dragOffset.x); 
            const newY = snapToGrid(pos.y - dragOffset.y); 
            draggedComponent.updatePosition(newX, newY);
            justDragged = true;
        } else if (activeToolType === 'wire' && wiringState.start) { 
            wiringState.end = pos; 
        } else if (draggedGhost) {
            draggedGhost.x = pos.x - dragOffset.x;
            draggedGhost.y = pos.y - dragOffset.y;
            const tempRect = { x: snapToGrid(draggedGhost.x), y: snapToGrid(draggedGhost.y), width: draggedGhost.width, height: draggedGhost.height };
            draggedGhost.isColliding = checkCollision(tempRect);
        }
        draw();
    });

    canvas.addEventListener('click', (e) => {
        if (justDragged) return;
        const { x, y } = getCanvasMousePos(e);

        if (selectedWire && wireEditorUI.colorRect) {
            const cr = wireEditorUI.colorRect; const tr = wireEditorUI.thickRect; const dr = wireEditorUI.deleteRect;
            if (x >= cr.x && x <= cr.x + cr.width && y >= cr.y && y <= cr.y + cr.height) { selectedWire.color = WIRE_COLORS[selectedWire.color] || '#f6e05e'; draw(); return; }
            if (x >= tr.x && x <= tr.x + tr.width && y >= tr.y && y <= tr.y + tr.height) { selectedWire.thickness = WIRE_THICKNESS[selectedWire.thickness] || 3; draw(); return; }
            if (x >= dr.x && x <= dr.x + dr.width && y >= dr.y && y <= dr.y + dr.height) { wires = wires.filter(w => w.id !== selectedWire.id); selectedWire = null; draw(); return; }
        }

        const isComponentTool = ['nfb', 'bulb', 'switch', 'breaker', 'contactor', 'fuse'].includes(activeToolType);
        if (isComponentTool) {
            selectedComponent = null;
            const clickedOnComponent = components.some(c => c.isUnderMouse(x, y));
            const sX = snapToGrid(x); const sY = snapToGrid(y);

            if (placementPreview) {
                const tempPreviewComp = createTempComponent(placementPreview.type, placementPreview.x, placementPreview.y);
                const mouseOnPreview = (x >= tempPreviewComp.x && x <= tempPreviewComp.x + tempPreviewComp.width && y >= tempPreviewComp.y && y <= tempPreviewComp.y + tempPreviewComp.height);
                
                if (mouseOnPreview) {
                    const rect = { x: placementPreview.x, y: placementPreview.y, width: tempPreviewComp.width, height: tempPreviewComp.height };
                    if (!checkCollision(rect)) {
                        const newComp = createTempComponent(placementPreview.type, placementPreview.x, placementPreview.y);
                        if (newComp) components.push(newComp);
                    }
                    placementPreview = null;
                } else {
                    placementPreview = null;
                }
            } else if (!clickedOnComponent) {
                const tempComp = createTempComponent(activeToolType, sX, sY);
                placementPreview = { type: activeToolType, x: tempComp.x, y: tempComp.y };
            }
        } else {
            const clickedComponent = components.find(c => c.isUnderMouse(x, y));
            const clickedConnector = components.flatMap(c => c.connectors).find(c => Math.hypot(c.x - x, c.y - y) < GRID_SIZE / 2);

            if (activeToolType === null && clickedConnector) {
                const isConnected = wires.some(w => w.start.id === clickedConnector.id || w.end.id === clickedConnector.id);
                if (!isConnected) {
                    handleToolClick(document.getElementById('wire-tool'));
                    wiringState.start = clickedConnector;
                    wiringPathPoints.push({ x: clickedConnector.x, y: clickedConnector.y });
                    draw();
                    return; 
                }
            }

            if (activeToolType === 'delete') {
                if (clickedComponent) {
                    wires = wires.filter(w => w.start.parent.id !== clickedComponent.id && w.end.parent.id !== clickedComponent.id);
                    components = components.filter(c => c.id !== clickedComponent.id);
                } else {
                    const wireToDelete = wires.find(w => { if (!w.path || w.path.length < 2) return false; for (let i = 0; i < w.path.length - 1; i++) { if (pDistance(x, y, w.path[i].x, w.path[i].y, w.path[i+1].x, w.path[i+1].y) < 5) return true; } return false; });
                    if (wireToDelete) wires = wires.filter(w => w.id !== wireToDelete.id);
                }
                selectedWire = null;
                selectedComponent = null;
            } else if (activeToolType === 'wire') {
                selectedComponent = null;
                if (clickedConnector) {
                    if (!wiringState.start) {
                        wiringState.start = clickedConnector; wiringPathPoints.push({ x: clickedConnector.x, y: clickedConnector.y });
                    } else if (wiringState.start.id !== clickedConnector.id) {
                        wiringState.end = { x: clickedConnector.x, y: clickedConnector.y };
                        wires.push(new Wire(wiringState.start, clickedConnector, getPreviewPath()));
                        wiringState = { start: null, end: null }; wiringPathPoints = [];
                    }
                } else if (wiringState.start) {
                    wiringState.end = { x, y };
                    wiringPathPoints = getPreviewPath();
                    wiringState.end = null;
                }
                selectedWire = null;
            } else {
                let somethingWasClicked = false;
                const wireToSelect = wires.find(w => { if (!w.path || w.path.length < 2) return false; for (let i = 0; i < w.path.length - 1; i++) { if (pDistance(x, y, w.path[i].x, w.path[i].y, w.path[i+1].x, w.path[i+1].y) < 6) return true; } return false; });

                if (wireToSelect) { 
                    selectedWire = wireToSelect; 
                    selectedComponent = null;
                    somethingWasClicked = true; 
                } else if (clickedComponent) {
                    selectedComponent = clickedComponent;
                    selectedWire = null;
                    if (clickedComponent.type === 'switch' && clickedComponent.switchType.startsWith('pushbutton')) return;
                    if (typeof clickedComponent.toggle === 'function') {
                        clickedComponent.toggle(e.shiftKey); 
                    }
                    somethingWasClicked = true;
                }
                
                if (!somethingWasClicked) { 
                    selectedWire = null; 
                    selectedComponent = null;
                }
            }
        }
        draw();
    });

    canvas.addEventListener('dblclick', (e) => {
        const { x, y } = getCanvasMousePos(e); const clickedComponent = components.find(c => c.isUnderMouse(x, y));
        if (clickedComponent) {
            selectedComponentForEdit = clickedComponent;
            if (clickedComponent.type === 'nfb') { poleModalTitle.textContent = `ç·¨è¼¯ NFB æ¥µæ€§`; openPoleModal(['1P', '2P', '3P', '4P']); }
            else if (clickedComponent.type === 'breaker') { poleModalTitle.textContent = `ç·¨è¼¯æ–·è·¯å™¨æ¥µæ•¸`; openPoleModal(['1P', '2P', '3P']); }
            else if (clickedComponent.type === 'switch') { switchModal.classList.remove('hidden'); }
            else if (clickedComponent.type === 'bulb') { clickedComponent.cycleColor(); draw(); }
            else if (clickedComponent.type === 'fuse' && clickedComponent.isBlown) {
                clickedComponent.isBlown = false;
                draw();
            }
        }
    });

    function openPoleModal(options) {
        poleOptionsContainer.innerHTML = '';
        options.forEach(opt => {
            const btn = document.createElement('button');
            btn.dataset.poles = opt;
            btn.className = 'pole-btn flex-1 bg-blue-600 hover:bg-blue-700 p-2 rounded';
            btn.textContent = opt;
            poleOptionsContainer.appendChild(btn);
        });
        poleModal.classList.remove('hidden');
    }

    canvas.addEventListener('mousedown', (e) => {
        if (e.button === 1) { // Middle mouse button for panning
            isPanning = true;
            panStart = { x: e.clientX, y: e.clientY };
            canvas.style.cursor = 'grabbing';
            e.preventDefault();
            return;
        }
        
        const pos = getCanvasMousePos(e);
        justDragged = false;
        
        const comp = components.find(c => c.isUnderMouse(pos.x, pos.y));
        const tempPreviewComp = placementPreview ? createTempComponent(placementPreview.type, placementPreview.x, placementPreview.y) : null;
        const mouseOnPreview = tempPreviewComp && (pos.x >= tempPreviewComp.x && pos.x <= tempPreviewComp.x + tempPreviewComp.width && pos.y >= tempPreviewComp.y && pos.y <= tempPreviewComp.y + tempPreviewComp.height);
        const isComponentTool = ['nfb', 'bulb', 'switch', 'breaker', 'contactor', 'fuse'].includes(activeToolType);

        if (activeToolType === 'move' && comp) {
             canvas.style.cursor = 'grabbing';
             draggedComponent = comp;
             draggedComponent.originalX = comp.x; draggedComponent.originalY = comp.y;
             dragOffset = { x: pos.x - draggedComponent.x, y: pos.y - draggedComponent.y };
        } else if (activeToolType === null || isComponentTool) {
             if (mouseOnPreview) {
                longPressTimer = setTimeout(() => {
                    isDraggingPreview = true;
                    dragOffset = { x: pos.x - placementPreview.x, y: pos.y - placementPreview.y };
                    longPressTimer = null;
                }, 500);
            } else if (comp) {
                potentialDragComponent = comp;
                longPressStartPos = pos;
                longPressTimer = setTimeout(() => {
                    isLongPressDrag = true;
                    draggedComponent = potentialDragComponent;
                    draggedComponent.originalX = comp.x; draggedComponent.originalY = comp.y;
                    dragOffset = { x: longPressStartPos.x - draggedComponent.x, y: longPressStartPos.y - draggedComponent.y };
                    selectedWire = null;
                    selectedComponent = null;
                    canvas.style.cursor = 'grabbing';
                    draw();
                    longPressTimer = null;
                }, 500);

                if (comp.type === 'switch' && comp.switchType.startsWith('pushbutton')) {
                    isPressingButton = true; comp.press(); draw();
                }
            }
        }
    });

    canvas.addEventListener('mouseup', (e) => {
        if (isPanning) {
            isPanning = false;
            canvas.style.cursor = 'default';
        }
        clearTimeout(longPressTimer); longPressTimer = null;
        
        if (isDraggingPreview){
            const tempComp = createTempComponent(placementPreview.type, placementPreview.x, placementPreview.y);
            const rect = { x: placementPreview.x, y: placementPreview.y, width: tempComp.width, height: tempComp.height };
            if(checkCollision(rect)){
               placementPreview = null; // Cancel if dragged to colliding spot
            }
        }
        isDraggingPreview = false;

        if (activeToolType === 'move' || isLongPressDrag) canvas.style.cursor = (activeToolType === 'move' ? 'grab' : 'default');

        if (draggedComponent) {
            const rect = { x: draggedComponent.x, y: draggedComponent.y, width: draggedComponent.width, height: draggedComponent.height };
            if (checkCollision(rect, draggedComponent.id)) {
                draggedComponent.updatePosition(draggedComponent.originalX, draggedComponent.originalY);
            }
        }

        if (isLongPressDrag) isLongPressDrag = false;
        draggedComponent = null;

        if (isPressingButton) {
            isPressingButton = false;
            components.forEach(c => c.release && c.release());
        }
        
        draw();
        setTimeout(() => { justDragged = false; }, 10);
    });

    wireColorPicker.addEventListener('click', () => {
        wireColorIndex = (wireColorIndex + 1) % WIRE_DEFAULT_COLORS.length;
        defaultWireColor = WIRE_DEFAULT_COLORS[wireColorIndex];
        wireColorPicker.style.backgroundColor = defaultWireColor;
    });

    wireThicknessPicker.addEventListener('click', () => {
        defaultWireThickness = defaultWireThickness === 3 ? 6 : 3;
        wireThicknessPicker.textContent = defaultWireThickness === 3 ? 'ç´°' : 'ç²—';
    });

    // --- Toolbar Drag & Drop ---
    toolbar.addEventListener('dragstart', (e) => {
        const toolItem = e.target.closest('.tool-item');
        if(toolItem && toolItem.draggable){
             draggedToolType = toolItem.dataset.type;
             const tempComp = createTempComponent(draggedToolType, 0, 0);
             dragOffset.x = tempComp.width / 2;
             dragOffset.y = tempComp.height / 2;
        }
    });

    canvas.addEventListener('dragover', (e) => {
        e.preventDefault();
        if(!draggedToolType) return;
        const pos = getCanvasMousePos(e);
        const sX = snapToGrid(pos.x - dragOffset.x);
        const sY = snapToGrid(pos.y - dragOffset.y);
        const tempComp = createTempComponent(draggedToolType, sX, sY);

        draggedGhost = {
            type: draggedToolType,
            x: sX, y: sY,
            width: tempComp.width, height: tempComp.height,
            isColliding: checkCollision({ x: sX, y: sY, width: tempComp.width, height: tempComp.height })
        };
        draw();
    });
    
    canvas.addEventListener('dragleave', (e) => { draggedGhost = null; draw(); });
    canvas.addEventListener('drop', (e) => {
        e.preventDefault();
        if(draggedGhost && !draggedGhost.isColliding) {
            const newComp = createTempComponent(draggedGhost.type, draggedGhost.x, draggedGhost.y);
            if(newComp) components.push(newComp);
        }
        draggedToolType = null;
        draggedGhost = null;
        draw();
    });
    
    // --- KEYBOARD HANDLERS ---
    window.addEventListener('keydown', (e) => { 
        if (e.key === 'Escape') { 
            if (placementPreview) { placementPreview = null; } 
            else if(activeToolType === 'wire' && wiringState.start) { wiringState = { start: null, end: null }; wiringPathPoints = []; } 
            else if (selectedWire) { selectedWire = null; } 
            else if (selectedComponent) { selectedComponent = null; }
            else if (activeToolType) { 
                document.querySelector(`.tool-item[data-type="${activeToolType}"]`)?.classList.remove('active'); 
                activeToolType = null; 
                canvas.style.cursor = 'default'; 
            } 
            draw(); 
        } else if (activeToolType === 'wire' && e.key === 'Backspace' && wiringPathPoints.length > 1) { 
            wiringPathPoints.pop(); 
            draw(); 
        } else if (e.key === 'Delete' && selectedComponent) {
            wires = wires.filter(w => w.start.parent.id !== selectedComponent.id && w.end.parent.id !== selectedComponent.id);
            components = components.filter(c => c.id !== selectedComponent.id);
            selectedComponent = null;
            draw();
        }
    });
    
    // --- MODAL LOGIC ---
    poleOptionsContainer.addEventListener('click', (e) => { if (e.target.classList.contains('pole-btn')) { const poles = e.target.dataset.poles; if (selectedComponentForEdit) { selectedComponentForEdit.setPoles(poles); draw(); } poleModal.classList.add('hidden'); selectedComponentForEdit = null; } });
    closePoleModalBtn.addEventListener('click', () => { poleModal.classList.add('hidden'); selectedComponentForEdit = null; });
    switchModal.addEventListener('click', (e) => { if (e.target.classList.contains('switch-type-btn')) { const type = e.target.dataset.switchType; if (selectedComponentForEdit && selectedComponentForEdit.type === 'switch') { selectedComponentForEdit.setSwitchType(type); draw(); } switchModal.classList.add('hidden'); selectedComponentForEdit = null; } });
    closeSwitchModalBtn.addEventListener('click', () => { switchModal.classList.add('hidden'); selectedComponentForEdit = null; });

    // --- SAVE/LOAD LOGIC ---
    function saveLayout() {
        const layout = {
            components: components.map(c => {
                const data = {
                    id: c.id, type: c.type, x: c.x, y: c.y
                };
                if (c.poleType) data.poleType = c.poleType;
                if (c.switchType) data.switchType = c.switchType;
                if (c.colorIndex !== undefined) data.colorIndex = c.colorIndex;
                if (c.isOn !== undefined) data.isOn = c.isOn;
                if (c.isBlown !== undefined) data.isBlown = c.isBlown;
                if (c.state) data.state = c.state;
                if (c.position) data.position = c.position;
                return data;
            }),
            wires: wires.map(w => ({
                id: w.id,
                startConnectorId: w.start.id,
                endConnectorId: w.end.id,
                path: w.path,
                color: w.color,
                thickness: w.thickness
            })),
            nextId: nextId
        };

        const dataStr = JSON.stringify(layout, null, 2);
        const blob = new Blob([dataStr], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'circuit-layout.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    function loadLayout(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = e => {
            try {
                const layout = JSON.parse(e.target.result);
                reconstructLayout(layout);
            } catch (error) {
                console.error("Error parsing layout file:", error);
                alert("è®€å–æª”æ¡ˆå¤±æ•—ï¼Œè«‹ç¢ºèªæª”æ¡ˆæ ¼å¼æ˜¯å¦æ­£ç¢ºã€‚");
            }
        };
        reader.readAsText(file);
        fileInput.value = ''; // Reset input
    }
    
    function reconstructLayout(layout) {
        components = [];
        wires = [];
        nextId = 0;

        layout.components.forEach(data => {
            let comp;
            switch(data.type) {
                case 'nfb': comp = new NFB(data.x, data.y); break;
                case 'bulb': comp = new Bulb(data.x, data.y); break;
                case 'switch': comp = new Switch(data.x, data.y); break;
                case 'breaker': comp = new CircuitBreaker(data.x, data.y); break;
                case 'contactor': comp = new MagneticContactor(data.x, data.y); break;
                case 'fuse': comp = new FuseHolder(data.x, data.y); break;
            }
            if (comp) {
                // Restore all properties
                Object.assign(comp, data);
                // Rebuild connectors with the restored state
                comp._updateDimensions();
                comp._rebuildConnectors();
                components.push(comp);
            }
        });
        
        const allConnectors = new Map();
        components.forEach(c => c.connectors.forEach(conn => allConnectors.set(conn.id, conn)));

        layout.wires.forEach(data => {
            const start = allConnectors.get(data.startConnectorId);
            const end = allConnectors.get(data.endConnectorId);
            if (start && end) {
                const wire = new Wire(start, end, data.path);
                wire.id = data.id;
                wire.color = data.color;
                wire.thickness = data.thickness;
                wires.push(wire);
            }
        });

        nextId = layout.nextId || 0;
        draw();
    }


    // --- INITIALIZATION ---
    window.addEventListener('resize', resizeCanvas);
    document.querySelectorAll('#toolbar .tool-item[data-type]').forEach(el => {
       el.addEventListener('click', (e) => handleToolClick(e.currentTarget));
    });
    
    document.getElementById('bulb-tool-item').addEventListener('dblclick', () => {
        nextBulbColorIndex = (nextBulbColorIndex + 1) % bulbColors.length;
        const color = bulbColors[nextBulbColorIndex].color;
        document.getElementById('bulb-tool-item').style.boxShadow = `0 0 10px 3px ${color}`;
        setTimeout(() => { document.getElementById('bulb-tool-item').style.boxShadow = ''; }, 300);
    });

    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const zoomIntensity = 0.1;
        const wheel = e.deltaY < 0 ? 1 : -1;
        const zoom = Math.exp(wheel * zoomIntensity);
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const mousePointX = (mouseX - view.tx) / view.scale;
        const mousePointY = (mouseY - view.ty) / view.scale;

        view.scale *= zoom;
        view.scale = Math.max(0.25, Math.min(4, view.scale));

        view.tx = mouseX - mousePointX * view.scale;
        view.ty = mouseY - mousePointY * view.scale;

        draw();
    });

    saveButton.addEventListener('click', saveLayout);
    loadButton.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', loadLayout);

    resizeCanvas();
    wireColorPicker.style.backgroundColor = defaultWireColor;
    
</script>
</body>
</html>

