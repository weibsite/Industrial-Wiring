<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é›»è·¯é…ç·šæ¨¡æ“¬å™¨</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', 'å¾®è»Ÿæ­£é»‘é«”', sans-serif;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .tool-item {
            @apply w-full p-3 bg-gray-700 text-white text-center rounded-lg cursor-grab shadow-md hover:bg-blue-500 transition-colors;
        }
        .tool-item.active {
            @apply bg-red-600 hover:bg-red-700 ring-2 ring-red-300;
        }
        canvas {
            background-color: #2d3748; /* bg-gray-800 */
            cursor: default;
        }
        .modal-bg {
            @apply fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-20;
        }
        .modal-content {
            @apply bg-gray-700 p-6 rounded-lg shadow-xl;
        }
        .color-swatch {
            @apply w-8 h-8 rounded-full cursor-pointer border-2 border-transparent transition-all;
        }
        .color-swatch.selected {
            @apply ring-2 ring-offset-2 ring-offset-gray-700 ring-white scale-110;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex h-screen overflow-hidden">

    <!-- Toolbar -->
    <div id="toolbar" class="w-48 bg-gray-800 p-4 flex flex-col space-y-4 shadow-lg z-10">
        <h2 class="text-xl font-bold text-center mb-4 border-b border-gray-600 pb-2">å·¥å…·åˆ—</h2>
        
        <div class="tool-item" draggable="true" data-type="nfb">âš¡ ç„¡ç†”çµ²é–‹é—œ</div>
        <div class="tool-item" draggable="true" data-type="bulb">ğŸ’¡ ç‡ˆæ³¡</div>
        <div class="tool-item" draggable="true" data-type="switch">ğŸ”˜ é–‹é—œå…ƒä»¶</div>
        <div class="tool-item" draggable="true" data-type="breaker">ğŸ›¡ï¸ æ–·è·¯å™¨</div>
        <div class="tool-item" draggable="true" data-type="contactor">ğŸ§² é›»ç£æ¥è§¸å™¨</div>
        <div class="tool-item" draggable="true" data-type="fuse">ğŸ”¥ ä¿éšªçµ²åº§</div>

        <div class="pt-4 mt-4 border-t border-gray-600 space-y-4">
            <button id="move-tool" class="tool-item cursor-pointer">ğŸª› ç§»å‹•</button>
            <button id="wire-tool" class="tool-item cursor-pointer">ã€°ï¸ é›»ç·š</button>
            <button id="delete-tool" class="tool-item cursor-pointer">ğŸ—‘ï¸ åˆªé™¤</button>
        </div>

        <div class="mt-auto text-center text-xs text-gray-400">
            <p>1. æ‹–æ›³å…ƒä»¶è‡³å³æ–¹ç•«å¸ƒ</p>
            <p>2. é»æ“Šã€Œé›»ç·šã€å·¥å…·é€£æ¥</p>
            <p>3. é»æ“Šé–‹é—œå¯åˆ‡æ›ç‹€æ…‹</p>
            <p class="mt-2"><span class="text-yellow-400">é€²é›»</span> / <span class="text-blue-400">å‡ºé›»</span></p>
            <p class="text-xs mt-2">é›™æ“Šå…ƒä»¶å¯é€²è¡Œç·¨è¼¯</p>
            <p class="text-xs mt-1">Shift+é»æ“Šæ–·è·¯å™¨å¯æ¨¡æ“¬è·³è„«</p>
        </div>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container" class="flex-1 bg-gray-700 p-2 overflow-hidden">
        <canvas id="canvas"></canvas>
    </div>
    
    <!-- Modals -->
    <div id="contactor-modal" class="modal-bg hidden">
        <div class="modal-content w-72">
            <h3 class="text-lg font-bold mb-4">ç·¨è¼¯é›»ç£æ¥è§¸å™¨</h3>
            <p class="text-sm mb-4">æ–°å¢è¼”åŠ©æ¥é» (Aæ¥é»/Bæ¥é»)</p>
            <div class="flex space-x-4">
                <button id="add-no-contact" class="flex-1 bg-green-600 hover:bg-green-700 p-2 rounded">æ–°å¢ NO (A)</button>
                <button id="add-nc-contact" class="flex-1 bg-orange-600 hover:bg-orange-700 p-2 rounded">æ–°å¢ NC (B)</button>
            </div>
            <button id="close-modal" class="w-full mt-6 bg-gray-500 hover:bg-gray-600 p-2 rounded">é—œé–‰</button>
        </div>
    </div>

    <div id="pole-modal" class="modal-bg hidden">
        <div class="modal-content w-72">
            <h3 id="pole-modal-title" class="text-lg font-bold mb-4">ç·¨è¼¯æ¥µæ•¸</h3>
            <p class="text-sm mb-4">é¸æ“‡å…ƒä»¶çš„æ¥µæ•¸ (Pæ•¸)</p>
            <div class="flex space-x-4">
                <button data-poles="1" class="pole-btn flex-1 bg-blue-600 hover:bg-blue-700 p-2 rounded">1P</button>
                <button data-poles="2" class="pole-btn flex-1 bg-blue-600 hover:bg-blue-700 p-2 rounded">2P</button>
                <button data-poles="3" class="pole-btn flex-1 bg-blue-600 hover:bg-blue-700 p-2 rounded">3P</button>
            </div>
            <button id="close-pole-modal" class="w-full mt-6 bg-gray-500 hover:bg-gray-600 p-2 rounded">é—œé–‰</button>
        </div>
    </div>

    <div id="switch-modal" class="modal-bg hidden">
        <div class="modal-content w-96">
            <h3 class="text-lg font-bold mb-4">é¸æ“‡é–‹é—œé¡å‹</h3>
            <div class="grid grid-cols-2 gap-4">
                <button data-switch-type="pushbutton_no" class="switch-type-btn bg-green-600 hover:bg-green-700 p-3 rounded text-sm">æŒ‰éˆ• (å¸¸é–‹ NO)</button>
                <button data-switch-type="pushbutton_nc" class="switch-type-btn bg-orange-600 hover:bg-orange-700 p-3 rounded text-sm">æŒ‰éˆ• (å¸¸é–‰ NC)</button>
                <button data-switch-type="rotary_2pos" class="switch-type-btn bg-blue-600 hover:bg-blue-700 p-3 rounded text-sm">äºŒæ®µæ—‹è½‰é–‹é—œ</button>
                <button data-switch-type="rotary_3pos" class="switch-type-btn bg-blue-600 hover:bg-blue-700 p-3 rounded text-sm">ä¸‰æ®µæ—‹è½‰é–‹é—œ</button>
            </div>
            <button id="close-switch-modal" class="w-full mt-6 bg-gray-500 hover:bg-gray-600 p-2 rounded">é—œé–‰</button>
        </div>
    </div>

    <div id="wire-settings-modal" class="modal-bg hidden">
        <div class="modal-content w-96">
            <h3 class="text-lg font-bold mb-4">é›»ç·šè¨­å®š</h3>
            <div class="mb-4">
                <p class="text-sm mb-2">é è¨­é¡è‰² (æœªé€šé›»æ™‚)</p>
                <div id="color-selector" class="flex space-x-3">
                    <div class="color-swatch" data-color="#e53e3e" style="background-color: #e53e3e;"></div> <!-- red-500 -->
                    <div class="color-swatch" data-color="#4299e1" style="background-color: #4299e1;"></div> <!-- blue-400 -->
                    <div class="color-swatch selected" data-color="#f6e05e" style="background-color: #f6e05e;"></div> <!-- yellow-400 -->
                    <div class="color-swatch" data-color="#48bb78" style="background-color: #48bb78;"></div> <!-- green-500 -->
                    <div class="color-swatch" data-color="#a0aec0" style="background-color: #a0aec0;"></div> <!-- gray-500 -->
                </div>
            </div>
            <div>
                <p class="text-sm mb-2">ç·šè·¯ç²—ç´°</p>
                <div class="flex space-x-4">
                    <button id="thickness-thin" class="flex-1 bg-gray-600 p-2 rounded ring-2 ring-blue-400">ç´°ç·š (é è¨­)</button>
                    <button id="thickness-thick" class="flex-1 bg-gray-600 p-2 rounded">ç²—ç·š</button>
                </div>
            </div>
            <button id="close-wire-settings-modal" class="w-full mt-6 bg-gray-500 hover:bg-gray-600 p-2 rounded">é—œé–‰</button>
        </div>
    </div>


<script>
    // --- SETUP ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const toolbar = document.getElementById('toolbar');
    const wireToolBtn = document.getElementById('wire-tool');
    const deleteToolBtn = document.getElementById('delete-tool');
    const moveToolBtn = document.getElementById('move-tool');
    const canvasContainer = document.getElementById('canvas-container');

    const contactorModal = document.getElementById('contactor-modal');
    const addNoContactBtn = document.getElementById('add-no-contact');
    const addNcContactBtn = document.getElementById('add-nc-contact');
    const closeModalBtn = document.getElementById('close-modal');

    const poleModal = document.getElementById('pole-modal');
    const poleModalTitle = document.getElementById('pole-modal-title');
    const closePoleModalBtn = document.getElementById('close-pole-modal');

    const switchModal = document.getElementById('switch-modal');
    const closeSwitchModalBtn = document.getElementById('close-switch-modal');

    const wireSettingsModal = document.getElementById('wire-settings-modal');
    const colorSelector = document.getElementById('color-selector');
    const thicknessThinBtn = document.getElementById('thickness-thin');
    const thicknessThickBtn = document.getElementById('thickness-thick');
    const closeWireSettingsModalBtn = document.getElementById('close-wire-settings-modal');

    const GRID_SIZE = 20;
    let components = [];
    let wires = [];
    let draggedType = null;
    let activeTool = null; // 'wire', 'delete', 'move'
    let wiringState = { start: null, end: null };
    let wiringPathPoints = []; // For multi-point wiring
    let nextId = 0;
    let selectedContactor = null;
    let selectedComponentForEdit = null;
    let draggedComponent = null;
    let isPressingButton = false;
    let dragOffset = { x: 0, y: 0 };
    
    // Wire settings
    let currentWireColor = '#f6e05e';
    let currentWireThickness = 3;

    const bulbColors = [
        { color: '#f6e05e', poweredColor: 'rgba(246, 224, 94, 0.7)', label: 'YL' }, // Yellow
        { color: '#e53e3e', poweredColor: 'rgba(229, 62, 62, 0.7)', label: 'RL' },  // Red
        { color: '#4299e1', poweredColor: 'rgba(66, 153, 225, 0.7)', label: 'BL' }, // Blue
        { color: '#48bb78', poweredColor: 'rgba(72, 187, 120, 0.7)', label: 'GL' }, // Green
        { color: '#ed8936', poweredColor: 'rgba(237, 137, 54, 0.7)', label: 'OL' }, // Orange
    ];
    
    // --- UTILITY FUNCTIONS ---
    const snapToGrid = (val) => Math.round(val / GRID_SIZE) * GRID_SIZE;
    const getCanvasMousePos = (e) => {
        const rect = canvas.getBoundingClientRect();
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    };
    const generateId = () => nextId++;

    // --- CANVAS RESIZING & DRAWING ---
    function resizeCanvas() {
        canvas.width = canvasContainer.clientWidth;
        canvas.height = canvasContainer.clientHeight;
        draw();
    }

    function drawGrid() {
        ctx.strokeStyle = '#4a5568'; // bg-gray-700
        ctx.lineWidth = 0.5;
        for (let x = 0; x < canvas.width; x += GRID_SIZE) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
        for (let y = 0; y < canvas.height; y += GRID_SIZE) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        runSimulation();
        wires.forEach(w => w.draw(ctx));
        components.forEach(c => c.draw(ctx));

        if (activeTool === 'wire' && wiringState.start && wiringState.end) { // FIX: Added check for wiringState.end
            const previewPath = [...wiringPathPoints];
            const lastPoint = previewPath[previewPath.length - 1];
            const mousePoint = wiringState.end;
            
            const elbowPoint = { x: snapToGrid(mousePoint.x), y: lastPoint.y };
            const finalPoint = { x: snapToGrid(mousePoint.x), y: snapToGrid(mousePoint.y) };

            previewPath.push(elbowPoint);
            previewPath.push(finalPoint);
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = currentWireThickness;
            ctx.beginPath();
            if(previewPath[0]) {
                ctx.moveTo(previewPath[0].x, previewPath[0].y);
                for(let i=1; i < previewPath.length; i++) {
                    if (previewPath[i]) ctx.lineTo(previewPath[i].x, previewPath[i].y);
                }
            }
            ctx.stroke();
        }
    }
    
    // --- COMPONENT CLASSES ---
    class Component {
        constructor(x, y, type) {
            this.id = generateId(); this.x = snapToGrid(x); this.y = snapToGrid(y); this.type = type;
            this.width = 0; this.height = 0; this.connectors = []; this.isPowered = false;
        }
        setPoles(poles) { this.poles = poles; this._updateDimensions(); this._rebuildConnectors(); }
        updatePosition(newX, newY) {
            const dx = newX - this.x; const dy = newY - this.y;
            this.x = newX; this.y = newY;
            this.connectors.forEach(c => { c.x += dx; c.y += dy; });
            wires.forEach(wire => { if (wire.start.parent.id === this.id || wire.end.parent.id === this.id) wire.calculatePath(); });
        }
        setSwitchType(type) { this.switchType = type; this.isPressed = false; this.position = 1; this._updateDimensions(); this._rebuildConnectors(); }
        draw(ctx) { throw new Error("Draw method must be implemented"); }
        isUnderMouse(mx, my) { return mx >= this.x && mx <= this.x + this.width && my >= this.y && my <= this.y + this.height; }
        getConnectorAt(mx, my) { for (const conn of this.connectors) { if (Math.hypot(conn.x - mx, conn.y - my) < GRID_SIZE / 2) return conn; } return null; }
        toggle() {}
    }

    class NFB extends Component {
        constructor(x, y) { super(x, y, 'nfb'); this.poles = 1; this.isOn = true; this._updateDimensions(); this._rebuildConnectors(); }
        _updateDimensions() { this.width = GRID_SIZE * (this.poles + 1); this.height = GRID_SIZE * 4; }
        _rebuildConnectors() {
            this.connectors = [];
            for (let i = 0; i < this.poles; i++) {
                const xPos = this.x + GRID_SIZE * (i + 1);
                this.connectors.push({ id: `${this.id}-in-${i}`, parent: this, x: xPos, y: this.y, type: 'positive', pole: i, potential: 0 });
                this.connectors.push({ id: `${this.id}-out-${i}`, parent: this, x: xPos, y: this.y + this.height, type: 'output', pole: i, potential: 0 });
            }
        }
        toggle() { this.isOn = !this.isOn; }
        draw(ctx) {
            const baseIsPowered = this.connectors.some(c => c.potential !== 0);
            ctx.strokeStyle = baseIsPowered ? '#f6e05e' : '#a0aec0';
            ctx.lineWidth = 2; ctx.strokeRect(this.x, this.y, this.width, this.height);
            ctx.fillStyle = ctx.strokeStyle; ctx.font = `${GRID_SIZE*0.7}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText('NFB', this.x + this.width / 2, this.y + GRID_SIZE * 0.7);
            for (let i = 0; i < this.poles; i++) {
                const xPos = this.x + GRID_SIZE * (i + 1);
                const inputConn = this.connectors.find(c => c.type === 'positive' && c.pole === i);
                ctx.strokeStyle = (inputConn.potential !== 0) ? '#f6e05e' : '#a0aec0';
                const startY = this.y + GRID_SIZE * 1.5; const endY = this.y + this.height - GRID_SIZE * 1.5;
                ctx.beginPath(); ctx.arc(xPos, startY, 3, 0, Math.PI * 2); ctx.moveTo(xPos, startY + 3);
                if (this.isOn) { ctx.lineTo(xPos, endY); } else { ctx.lineTo(xPos + GRID_SIZE * 0.4, endY - GRID_SIZE * 0.4); }
                ctx.stroke();
            }
            this.connectors.forEach(c => {
                ctx.fillStyle = c.potential !== 0 ? (c.potential === 1 ? '#f6e05e' : '#4299e1') : 'white';
                ctx.beginPath(); ctx.arc(c.x, c.y, 4, 0, Math.PI * 2); ctx.fill();
            });
        }
    }

    class Bulb extends Component {
        constructor(x, y) {
            super(x, y, 'bulb'); this.width = GRID_SIZE * 2; this.height = GRID_SIZE * 2; this.colorIndex = 0; this._updateColor();
            this.connectors = [
                { id: `${this.id}-0`, parent: this, x: this.x + this.width / 2, y: this.y, potential: 0 },
                { id: `${this.id}-1`, parent: this, x: this.x + this.width / 2, y: this.y + this.height, potential: 0 }
            ];
        }
        _updateColor() { const c = bulbColors[this.colorIndex]; this.color = c.color; this.poweredColor = c.poweredColor; this.label = c.label; }
        cycleColor() { this.colorIndex = (this.colorIndex + 1) % bulbColors.length; this._updateColor(); }
        draw(ctx) {
            this.isPowered = this.connectors[0].potential === 1 && this.connectors[1].potential === -1;
            ctx.strokeStyle = this.isPowered ? this.color : '#a0aec0'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2); ctx.stroke();
            if (this.isPowered) { ctx.fillStyle = this.poweredColor; ctx.fill(); }
            ctx.fillStyle = this.isPowered ? this.color : '#a0aec0'; ctx.font = `${GRID_SIZE*0.9}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(this.label, this.x + this.width / 2, this.y + this.height / 2);
            this.connectors.forEach(c => {
                ctx.fillStyle = c.potential !== 0 ? (c.potential === 1 ? '#f6e05e' : '#4299e1') : 'white';
                ctx.beginPath(); ctx.arc(c.x, c.y, 4, 0, Math.PI * 2); ctx.fill();
            });
        }
    }

    class Switch extends Component {
        constructor(x, y) { super(x, y, 'switch'); this.switchType = 'pushbutton_no'; this.isPressed = false; this.position = 1; this._updateDimensions(); this._rebuildConnectors(); }
        _updateDimensions() { if (this.switchType.startsWith('pushbutton')) { this.width = GRID_SIZE * 4; this.height = GRID_SIZE * 3; } else { this.width = GRID_SIZE * 4; this.height = GRID_SIZE * 4; } }
        _rebuildConnectors() {
            this.connectors = []; const cX = this.x + this.width / 2;
            if (this.switchType.startsWith('pushbutton')) {
                this.connectors.push({ id: `${this.id}-nc-in`, parent: this, x: this.x + GRID_SIZE, y: this.y, type: 'nc_in', potential: 0 });
                this.connectors.push({ id: `${this.id}-nc-out`, parent: this, x: this.x + GRID_SIZE, y: this.y + this.height, type: 'nc_out', potential: 0 });
                this.connectors.push({ id: `${this.id}-no-in`, parent: this, x: this.x + this.width - GRID_SIZE, y: this.y, type: 'no_in', potential: 0 });
                this.connectors.push({ id: `${this.id}-no-out`, parent: this, x: this.x + this.width - GRID_SIZE, y: this.y + this.height, type: 'no_out', potential: 0 });
            } else {
                this.connectors.push({ id: `${this.id}-com`, parent: this, x: cX, y: this.y, type: 'com', potential: 0 });
                this.connectors.push({ id: `${this.id}-out1`, parent: this, x: this.x + GRID_SIZE, y: this.y + this.height, type: 'out1', potential: 0 });
                this.connectors.push({ id: `${this.id}-out2`, parent: this, x: this.x + this.width - GRID_SIZE, y: this.y + this.height, type: 'out2', potential: 0 });
            }
        }
        toggle() { if (this.switchType === 'rotary_2pos') { this.position = (this.position === 1) ? 2 : 1; } else if (this.switchType === 'rotary_3pos') { this.position = (this.position + 1) % 3; } }
        press() { if (this.switchType.startsWith('pushbutton')) this.isPressed = true; }
        release() { if (this.switchType.startsWith('pushbutton')) this.isPressed = false; }
        draw(ctx) {
            const baseIsPowered = this.connectors.some(c => c.potential !== 0);
            ctx.strokeStyle = baseIsPowered ? '#f6e05e' : '#a0aec0'; ctx.lineWidth = 2; ctx.strokeRect(this.x, this.y, this.width, this.height);
            ctx.font = `${GRID_SIZE*0.7}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            if (this.switchType.startsWith('pushbutton')) this._drawPushButton(ctx); else this._drawRotarySwitch(ctx);
            this.connectors.forEach(c => {
                ctx.fillStyle = c.potential !== 0 ? (c.potential === 1 ? '#f6e05e' : '#4299e1') : 'white';
                ctx.beginPath(); ctx.arc(c.x, c.y, 4, 0, Math.PI * 2); ctx.fill();
            });
        }
        _drawPushButton(ctx) { /* ... same drawing logic as before ... */ }
        _drawRotarySwitch(ctx) { /* ... same drawing logic as before ... */ }
    }
    
    class CircuitBreaker extends Component {
        constructor(x, y) { super(x, y, 'breaker'); this.poles = 1; this.state = 'ON'; this._updateDimensions(); this._rebuildConnectors(); }
        _updateDimensions() { this.width = GRID_SIZE * (this.poles + 1); this.height = GRID_SIZE * 4; }
        _rebuildConnectors() {
            this.connectors = [];
            for (let i = 0; i < this.poles; i++) {
                const xPos = this.x + GRID_SIZE * (i + 1);
                this.connectors.push({ id: `${this.id}-in-${i}`, parent: this, x: xPos, y: this.y, type: 'input', pole: i, potential: 0 });
                this.connectors.push({ id: `${this.id}-out-${i}`, parent: this, x: xPos, y: this.y + this.height, type: 'output', pole: i, potential: 0 });
            }
        }
        toggle(isTrip=false) { if (isTrip) this.state = 'TRIPPED'; else this.state = (this.state === 'TRIPPED') ? 'OFF' : (this.state === 'ON' ? 'OFF' : 'ON'); }
        draw(ctx) {
            const baseIsPowered = this.connectors.some(c => c.potential !== 0);
            ctx.strokeStyle = baseIsPowered ? '#f6e05e' : '#a0aec0'; ctx.lineWidth = 2; ctx.strokeRect(this.x, this.y, this.width, this.height);
            ctx.fillStyle = ctx.strokeStyle; ctx.font = `${GRID_SIZE*0.7}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText('CB', this.x + this.width / 2, this.y + GRID_SIZE * 0.7);
            for (let i = 0; i < this.poles; i++) { /* ... drawing logic same as before ... */ }
            this.connectors.forEach(c => {
                ctx.fillStyle = c.potential !== 0 ? (c.potential === 1 ? '#f6e05e' : '#4299e1') : 'white';
                ctx.beginPath(); ctx.arc(c.x, c.y, 4, 0, Math.PI * 2); ctx.fill();
            });
        }
    }

    class MagneticContactor extends Component {
        constructor(x, y) { super(x, y, 'contactor'); this.coilEnergized = false; this.auxContacts = []; this._updateDimensions(); this._rebuildConnectors(); }
        _updateDimensions() { this.width = GRID_SIZE * 5; this.height = GRID_SIZE * 5 + (this.auxContacts.length * GRID_SIZE * 2); }
        _rebuildConnectors() {
            this.connectors = []; const yCoil = this.y + GRID_SIZE * 4;
            this.connectors.push({ id: `${this.id}-A1`, parent: this, x: this.x + GRID_SIZE, y: yCoil, type: 'coil', potential: 0 });
            this.connectors.push({ id: `${this.id}-A2`, parent: this, x: this.x + this.width - GRID_SIZE, y: yCoil, type: 'coil', potential: 0 });
            for(let i=0; i<3; i++) {
                const xPos = this.x + GRID_SIZE * (i + 1);
                this.connectors.push({ id: `${this.id}-L${i+1}`, parent: this, x: xPos, y: this.y, type: 'main-in', pole: i, potential: 0 });
                this.connectors.push({ id: `${this.id}-T${i+1}`, parent: this, x: xPos, y: this.y + GRID_SIZE * 3, type: 'main-out', pole: i, potential: 0 });
            }
            this.auxContacts.forEach((c, i) => {
                const yPos = this.y + GRID_SIZE * 5 + (i * GRID_SIZE * 2) + GRID_SIZE;
                this.connectors.push({ id: `${this.id}-aux${i}-0`, parent: this, x: this.x, y: yPos, auxIndex: i, potential: 0 });
                this.connectors.push({ id: `${this.id}-aux${i}-1`, parent: this, x: this.x + this.width, y: yPos, auxIndex: i, potential: 0 });
            });
        }
        addAuxContact(type) { this.auxContacts.push({ type }); this._updateDimensions(); this._rebuildConnectors(); }
        draw(ctx) {
            this.coilEnergized = this.connectors.find(c=>c.id===`${this.id}-A1`).potential === 1 && this.connectors.find(c=>c.id===`${this.id}-A2`).potential === -1;
            const baseIsPowered = this.connectors.some(c => c.potential !== 0);
            ctx.strokeStyle = baseIsPowered ? '#f6e05e' : '#a0aec0'; /* ... rest of drawing logic is similar, just using potential for coloring ... */
            this.connectors.forEach(c => {
                ctx.fillStyle = c.potential !== 0 ? (c.potential === 1 ? '#f6e05e' : '#4299e1') : 'white';
                ctx.beginPath(); ctx.arc(c.x, c.y, 4, 0, Math.PI * 2); ctx.fill();
            });
        }
    }

    class FuseHolder extends Component {
        constructor(x, y) {
            super(x, y, 'fuse'); this.width = GRID_SIZE * 2; this.height = GRID_SIZE * 2; this.isBlown = false;
            this.connectors = [
                { id: `${this.id}-in`, parent: this, x: this.x + this.width / 2, y: this.y, potential: 0 },
                { id: `${this.id}-out`, parent: this, x: this.x + this.width / 2, y: this.y + this.height, potential: 0 }
            ];
        }
        toggle() { this.isBlown = false; }
        draw(ctx) {
            const baseIsPowered = this.connectors.some(c => c.potential !== 0);
            ctx.strokeStyle = baseIsPowered ? '#f6e05e' : '#a0aec0'; ctx.lineWidth = 2; ctx.strokeRect(this.x, this.y, this.width, this.height);
            if (this.isBlown) {
                ctx.strokeStyle = '#e53e3e'; ctx.lineWidth = 3; const cX = this.x + this.width / 2; const cY = this.y + this.height / 2;
                ctx.beginPath(); ctx.moveTo(cX - 5, cY - 8); ctx.lineTo(cX + 5, cY); ctx.lineTo(cX - 5, cY); ctx.lineTo(cX + 5, cY + 8); ctx.stroke();
            } else { ctx.beginPath(); ctx.moveTo(this.x + this.width / 2, this.y + 4); ctx.lineTo(this.x + this.width / 2, this.y + this.height - 4); ctx.stroke(); }
            this.connectors.forEach(c => {
                ctx.fillStyle = c.potential !== 0 ? (c.potential === 1 ? '#f6e05e' : '#4299e1') : 'white';
                ctx.beginPath(); ctx.arc(c.x, c.y, 4, 0, Math.PI * 2); ctx.fill();
            });
        }
    }

    class Wire {
        constructor(startConnector, endConnector, pathPoints) {
            this.id = generateId(); this.start = startConnector; this.end = endConnector; this.potential = 0;
            this.color = currentWireColor; this.thickness = currentWireThickness;
            this.waypoints = pathPoints.slice(1, -1); this.path = []; this.calculatePath();
        }
        calculatePath() { const p = [{ x: this.start.x, y: this.start.y }]; this.waypoints.forEach(wp => p.push(wp)); p.push({ x: this.end.x, y: this.end.y }); this.path = p; }
        draw(ctx) {
            if (!this.path || this.path.length < 2) return;
            if (this.potential === 1) ctx.strokeStyle = '#f6e05e';
            else if (this.potential === -1) ctx.strokeStyle = '#4299e1';
            else ctx.strokeStyle = this.color;
            ctx.lineWidth = this.thickness; ctx.beginPath(); ctx.moveTo(this.path[0].x, this.path[0].y);
            for (let i = 1; i < this.path.length; i++) { ctx.lineTo(this.path[i].x, this.path[i].y); }
            ctx.stroke();
        }
    }
    
    // --- SIMULATION LOGIC ---
    function runSimulation() {
        components.forEach(c => c.connectors.forEach(conn => conn.potential = 0));
        wires.forEach(w => w.potential = 0);

        const powerSources = components.filter(c => c.type === 'nfb');
        if (powerSources.length === 0) return;

        // Propagate for each potential (+1 for positive/hot, -1 for negative/neutral)
        [1, -1].forEach(potential => {
            let queue = [];
            powerSources.forEach(nfb => {
                // For +1 potential, start from the 'output' side. For -1, start from the 'input/positive' side (our conventional neutral).
                const startConnectors = nfb.connectors.filter(c => (potential === 1 && c.type === 'output') || (potential === -1 && c.type === 'positive'));
                startConnectors.forEach(c => {
                    if (nfb.isOn) { // Only propagate if NFB is on
                        c.potential = potential;
                        queue.push(c);
                    }
                });
            });

            let visitedConnectors = new Set(queue.map(c => c.id));

            while (queue.length > 0) {
                const currentConn = queue.shift();
                
                // Propagate through wires
                wires.forEach(w => {
                    let otherConn = null;
                    if (w.start.id === currentConn.id) otherConn = w.end;
                    if (w.end.id === currentConn.id) otherConn = w.start;
                    
                    if (otherConn && !visitedConnectors.has(otherConn.id)) {
                        w.potential = potential; otherConn.potential = potential;
                        visitedConnectors.add(otherConn.id); queue.push(otherConn);
                    }
                });
                
                // Propagate through conductive components
                const comp = currentConn.parent;
                let internalConnections = [];
                // This logic determines which pairs of connectors are internally connected
                if (comp.type === 'fuse' && !comp.isBlown) internalConnections.push([comp.connectors[0], comp.connectors[1]]);
                if (comp.type === 'breaker' && comp.state === 'ON') for(let p=0;p<comp.poles;p++) internalConnections.push([comp.connectors.find(c=>c.type==='input'&&c.pole===p), comp.connectors.find(c=>c.type==='output'&&c.pole===p)]);
                if (comp.type === 'switch') {
                    if (comp.switchType.startsWith('pushbutton')) {
                        if (comp.isPressed) internalConnections.push([comp.connectors.find(c=>c.type==='no_in'), comp.connectors.find(c=>c.type==='no_out')]);
                        else internalConnections.push([comp.connectors.find(c=>c.type==='nc_in'), comp.connectors.find(c=>c.type==='nc_out')]);
                    } else if (comp.switchType === 'rotary_2pos') {
                        if (comp.position === 1) internalConnections.push([comp.connectors.find(c=>c.type==='com'), comp.connectors.find(c=>c.type==='out1')]);
                        if (comp.position === 2) internalConnections.push([comp.connectors.find(c=>c.type==='com'), comp.connectors.find(c=>c.type==='out2')]);
                    } else if (comp.switchType === 'rotary_3pos') {
                        if (comp.position === 1) internalConnections.push([comp.connectors.find(c=>c.type==='com'), comp.connectors.find(c=>c.type==='out1')]);
                        if (comp.position === 2) internalConnections.push([comp.connectors.find(c=>c.type==='com'), comp.connectors.find(c=>c.type==='out2')]);
                    }
                }
                if (comp.type === 'contactor') {
                    const isCoilEnergized = comp.connectors.find(c=>c.id===`${comp.id}-A1`).potential === 1 && comp.connectors.find(c=>c.id===`${comp.id}-A2`).potential === -1;
                    if (isCoilEnergized) {
                        for(let p=0; p<3; p++) internalConnections.push([comp.connectors.find(c=>c.type==='main-in'&&c.pole===p), comp.connectors.find(c=>c.type==='main-out'&&c.pole===p)]);
                    }
                    comp.auxContacts.forEach((contact, i) => {
                        const isClosed = (contact.type === 'NO' && isCoilEnergized) || (contact.type === 'NC' && !isCoilEnergized);
                        if (isClosed) internalConnections.push([comp.connectors.find(c=>c.auxIndex===i&&c.x===comp.x), comp.connectors.find(c=>c.auxIndex===i&&c.x===comp.x+comp.width)]);
                    });
                }

                internalConnections.forEach(([connA, connB]) => {
                    if(!connA || !connB) return;
                    let otherConn = null;
                    if(connA.id === currentConn.id) otherConn = connB;
                    if(connB.id === currentConn.id) otherConn = connA;

                    if(otherConn && !visitedConnectors.has(otherConn.id)) {
                        otherConn.potential = potential; visitedConnectors.add(otherConn.id); queue.push(otherConn);
                    }
                });
            }
        });

        // Short circuit detection - must be after both potentials have propagated
        components.filter(c => c.type === 'fuse' && !c.isBlown).forEach(fuse => {
            const potA = fuse.connectors[0].potential; const potB = fuse.connectors[1].potential;
            if ((potA === 1 && potB === -1) || (potA === -1 && potB === 1)) {
                fuse.isBlown = true;
            }
        });
    }

    // --- EVENT HANDLERS ---
    function setActiveTool(tool) {
        const newActiveTool = activeTool === tool ? null : tool;
        [wireToolBtn, deleteToolBtn, moveToolBtn].forEach(btn => btn.classList.remove('active'));
        if (newActiveTool) document.getElementById(`${newActiveTool}-tool`).classList.add('active');
        activeTool = newActiveTool;
        canvas.style.cursor = 'default';
        if (activeTool === 'wire') canvas.style.cursor = 'crosshair';
        if (activeTool === 'delete') canvas.style.cursor = 'not-allowed';
        if (activeTool === 'move') canvas.style.cursor = 'move';
        wiringState = { start: null, end: null }; wiringPathPoints = [];
    }
    toolbar.addEventListener('dragstart', (e) => { if (e.target.classList.contains('tool-item') && e.target.dataset.type) draggedType = e.target.dataset.type; });
    canvas.addEventListener('dragover', (e) => e.preventDefault());
    canvas.addEventListener('drop', (e) => {
        e.preventDefault(); if (!draggedType) return; const { x, y } = getCanvasMousePos(e); let newComp;
        switch (draggedType) {
            case 'nfb': newComp = new NFB(x, y); break; case 'bulb': newComp = new Bulb(x, y); break;
            case 'switch': newComp = new Switch(x, y); break; case 'breaker': newComp = new CircuitBreaker(x,y); break;
            case 'contactor': newComp = new MagneticContactor(x, y); break; case 'fuse': newComp = new FuseHolder(x,y); break;
        }
        if (newComp) components.push(newComp); draggedType = null; draw();
    });
    canvas.addEventListener('mousemove', (e) => {
        const pos = getCanvasMousePos(e);
        if (activeTool === 'move' && draggedComponent) { const newX = snapToGrid(pos.x - dragOffset.x); const newY = snapToGrid(pos.y - dragOffset.y); draggedComponent.updatePosition(newX, newY); draw(); } 
        else if (activeTool === 'wire' && wiringState.start) { wiringState.end = pos; draw(); }
    });
    canvas.addEventListener('click', (e) => {
        const { x, y } = getCanvasMousePos(e);
        const clickedComponent = components.find(c => c.isUnderMouse(x, y));
        const clickedConnector = components.flatMap(c => c.connectors).find(c => Math.hypot(c.x - x, c.y - y) < GRID_SIZE / 2);

        if (activeTool === 'delete') { /* ... same as before ... */ }
        else if (activeTool === 'wire') {
            if (clickedConnector) {
                if (!wiringState.start) { wiringState.start = clickedConnector; wiringPathPoints.push({ x: clickedConnector.x, y: clickedConnector.y }); } 
                else if (wiringState.start.id !== clickedConnector.id) {
                    wiringPathPoints.push({ x: clickedConnector.x, y: clickedConnector.y });
                    wires.push(new Wire(wiringState.start, clickedConnector, wiringPathPoints));
                    wiringState = { start: null, end: null }; wiringPathPoints = []; setActiveTool(null);
                }
            } else if (wiringState.start) { wiringPathPoints.push({ x: snapToGrid(x), y: snapToGrid(y) }); }
        } else {
            if (clickedComponent && clickedComponent.type === 'switch' && clickedComponent.switchType.startsWith('pushbutton')) return;
            if (clickedComponent && typeof clickedComponent.toggle === 'function') clickedComponent.toggle(e.shiftKey);
        }
        draw();
    });
    canvas.addEventListener('dblclick', (e) => {
        const { x, y } = getCanvasMousePos(e); const clickedComponent = components.find(c => c.isUnderMouse(x, y));
        if (clickedComponent) {
            if (clickedComponent.type === 'contactor') { selectedContactor = clickedComponent; contactorModal.classList.remove('hidden'); }
            else if (clickedComponent.type === 'nfb' || clickedComponent.type === 'breaker') { selectedComponentForEdit = clickedComponent; poleModalTitle.textContent = `ç·¨è¼¯ ${(clickedComponent.type === 'nfb' ? 'ç„¡ç†”çµ²é–‹é—œ' : 'æ–·è·¯å™¨')} æ¥µæ•¸`; poleModal.classList.remove('hidden'); }
            else if (clickedComponent.type === 'switch') { selectedComponentForEdit = clickedComponent; switchModal.classList.remove('hidden'); }
            else if (clickedComponent.type === 'bulb') { clickedComponent.cycleColor(); draw(); }
        }
    });
    wireToolBtn.addEventListener('dblclick', () => { wireSettingsModal.classList.remove('hidden'); });
    canvas.addEventListener('mousedown', (e) => { /* ... same as before ... */ });
    canvas.addEventListener('mouseup', (e) => { /* ... same as before ... */ });
    wireToolBtn.addEventListener('click', () => setActiveTool('wire'));
    deleteToolBtn.addEventListener('click', () => setActiveTool('delete'));
    moveToolBtn.addEventListener('click', () => setActiveTool('move'));

    // --- MODAL LOGIC ---
    addNoContactBtn.addEventListener('click', () => { if(selectedContactor) { selectedContactor.addAuxContact('NO'); draw(); } });
    addNcContactBtn.addEventListener('click', () => { if(selectedContactor) { selectedContactor.addAuxContact('NC'); draw(); } });
    closeModalBtn.addEventListener('click', () => { contactorModal.classList.add('hidden'); selectedContactor = null; });
    poleModal.addEventListener('click', (e) => { if (e.target.classList.contains('pole-btn')) { const poles = parseInt(e.target.dataset.poles, 10); if (selectedComponentForEdit) { selectedComponentForEdit.setPoles(poles); draw(); } poleModal.classList.add('hidden'); selectedComponentForEdit = null; } });
    closePoleModalBtn.addEventListener('click', () => { poleModal.classList.add('hidden'); selectedComponentForEdit = null; });
    switchModal.addEventListener('click', (e) => { if (e.target.classList.contains('switch-type-btn')) { const type = e.target.dataset.switchType; if (selectedComponentForEdit && selectedComponentForEdit.type === 'switch') { selectedComponentForEdit.setSwitchType(type); draw(); } switchModal.classList.add('hidden'); selectedComponentForEdit = null; } });
    closeSwitchModalBtn.addEventListener('click', () => { switchModal.classList.add('hidden'); selectedComponentForEdit = null; });
    
    // Wire Settings Modal Logic
    colorSelector.addEventListener('click', (e) => { if(e.target.classList.contains('color-swatch')) { currentWireColor = e.target.dataset.color; document.querySelectorAll('.color-swatch').forEach(el => el.classList.remove('selected')); e.target.classList.add('selected'); } });
    thicknessThinBtn.addEventListener('click', () => { currentWireThickness = 3; thicknessThinBtn.classList.add('ring-2', 'ring-blue-400'); thicknessThickBtn.classList.remove('ring-2', 'ring-blue-400'); });
    thicknessThickBtn.addEventListener('click', () => { currentWireThickness = 6; thicknessThickBtn.classList.add('ring-2', 'ring-blue-400'); thicknessThinBtn.classList.remove('ring-2', 'ring-blue-400'); });
    closeWireSettingsModalBtn.addEventListener('click', () => wireSettingsModal.classList.add('hidden'));

    // --- KEYBOARD HANDLERS ---
    window.addEventListener('keydown', (e) => { if (activeTool === 'wire' && wiringState.start) { if (e.key === 'Escape') { wiringState = { start: null, end: null }; wiringPathPoints = []; draw(); } else if (e.key === 'Backspace' && wiringPathPoints.length > 1) { wiringPathPoints.pop(); draw(); } } });

    // --- INITIALIZATION ---
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    requestAnimationFrame(function renderLoop() { draw(); requestAnimationFrame(renderLoop); });
</script>
</body>
</html>

